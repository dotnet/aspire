// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System.CommandLine;
using System.Globalization;
using System.Reflection;
using System.Text;
using Aspire.Hosting;
using Aspire.Hosting.Ats;

namespace AtsCapabilityDump;

/// <summary>
/// Tool for dumping ATS capabilities from Aspire assemblies to a text file.
/// This enables diffing capabilities across versions, similar to how
/// api/*.cs files track the public API surface.
/// </summary>
public static class Program
{
    public static Task<int> Main(string[] args)
    {
        var rootCommand = new RootCommand("Dumps ATS capabilities from Aspire assemblies to a file for tracking and diffing.");

        var assemblyOption = new Option<string[]?>("--assembly", "-a") { Description = "Path(s) to assembly file(s) to scan for capabilities." };
        var outputOption = new Option<string?>("--output", "-o") { Description = "Output file path. If not specified, writes to stdout." };
        var formatOption = new Option<string>("--format", "-f") { Description = "Output format (text or json)." };
        formatOption.DefaultValueFactory = _ => "text";
        var scanHostingOption = new Option<bool>("--scan-hosting") { Description = "Scan the Aspire.Hosting assembly (default: true)." };
        scanHostingOption.DefaultValueFactory = _ => true;

        rootCommand.Options.Add(assemblyOption);
        rootCommand.Options.Add(outputOption);
        rootCommand.Options.Add(formatOption);
        rootCommand.Options.Add(scanHostingOption);

        rootCommand.SetAction(static async (parseResult, token) =>
        {
            var assemblies = parseResult.GetValue<string[]?>("--assembly");
            var output = parseResult.GetValue<string?>("--output");
            var format = parseResult.GetValue<string>("--format") ?? "text";
            var scanHosting = parseResult.GetValue<bool>("--scan-hosting");

            await RunAsync(assemblies, output, format, scanHosting);
            return 0;
        });

        return rootCommand.Parse(args).InvokeAsync();
    }

    private static async Task RunAsync(string[]? assemblyPaths, string? output, string format, bool scanHosting)
    {
        var assembliesToScan = new List<Assembly>();

        // Add Aspire.Hosting assembly if requested
        if (scanHosting)
        {
            assembliesToScan.Add(typeof(IDistributedApplicationBuilder).Assembly);
        }

        // Add any specified assemblies
        if (assemblyPaths != null)
        {
            foreach (var assemblyPath in assemblyPaths)
            {
                if (!File.Exists(assemblyPath))
                {
                    Console.Error.WriteLine($"Assembly not found: {assemblyPath}");
                    continue;
                }

                try
                {
                    var assembly = Assembly.LoadFrom(assemblyPath);
                    assembliesToScan.Add(assembly);
                }
                catch (Exception ex)
                {
                    Console.Error.WriteLine($"Failed to load assembly {assemblyPath}: {ex.Message}");
                }
            }
        }

        if (assembliesToScan.Count == 0)
        {
            Console.Error.WriteLine("No assemblies to scan.");
            return;
        }

        // Scan for capabilities
        var result = AtsCapabilityScanner.ScanAssemblies(assembliesToScan);

        // Generate output
        var content = format.Equals("json", StringComparison.OrdinalIgnoreCase)
            ? GenerateJsonOutput(result)
            : GenerateTextOutput(result);

        // Write output
        if (!string.IsNullOrEmpty(output))
        {
            await File.WriteAllTextAsync(output, content);
            Console.WriteLine($"Capabilities written to: {output}");
        }
        else
        {
            Console.WriteLine(content);
        }
    }

    private static string GenerateTextOutput(AtsCapabilityScanner.ScanResult result)
    {
        var sb = new StringBuilder();

        sb.AppendLine("//------------------------------------------------------------------------------");
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("//     This file contains the ATS (Aspire Type System) capabilities.");
        sb.AppendLine("//     It is generated by the AtsCapabilityDump tool.");
        sb.AppendLine("//");
        sb.AppendLine("//     Changes to this file may indicate breaking changes to the polyglot API.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine("//------------------------------------------------------------------------------");
        sb.AppendLine();

        // Output handle types
        sb.AppendLine("// Handle Types (passed by reference)");
        sb.AppendLine("// -----------------------------------");
        foreach (var type in result.HandleTypes.OrderBy(t => t.AtsTypeId))
        {
            sb.AppendLine(CultureInfo.InvariantCulture, $"// Type: {type.AtsTypeId}");
            if (type.IsInterface)
            {
                sb.AppendLine("//   Kind: Interface");
            }
            if (type.HasExposeProperties)
            {
                sb.AppendLine("//   ExposeProperties: true");
            }
            if (type.HasExposeMethods)
            {
                sb.AppendLine("//   ExposeMethods: true");
            }
        }
        sb.AppendLine();

        // Output DTO types
        if (result.DtoTypes.Count > 0)
        {
            sb.AppendLine("// DTO Types (serialized as JSON)");
            sb.AppendLine("// ------------------------------");
            foreach (var dto in result.DtoTypes.OrderBy(d => d.TypeId))
            {
                sb.AppendLine(CultureInfo.InvariantCulture, $"// DTO: {dto.TypeId}");
                foreach (var prop in dto.Properties.OrderBy(p => p.Name))
                {
                    var optional = prop.IsOptional ? "?" : "";
                    sb.AppendLine(CultureInfo.InvariantCulture, $"//   {prop.Name}{optional}: {prop.Type?.TypeId ?? "unknown"}");
                }
            }
            sb.AppendLine();
        }

        // Output enum types
        if (result.EnumTypes.Count > 0)
        {
            sb.AppendLine("// Enum Types");
            sb.AppendLine("// ----------");
            foreach (var enumType in result.EnumTypes.OrderBy(e => e.TypeId))
            {
                sb.AppendLine(CultureInfo.InvariantCulture, $"// Enum: {enumType.TypeId}");
                sb.AppendLine(CultureInfo.InvariantCulture, $"//   Values: {string.Join(", ", enumType.Values)}");
            }
            sb.AppendLine();
        }

        // Output capabilities grouped by target type
        sb.AppendLine("// Capabilities");
        sb.AppendLine("// ------------");
        sb.AppendLine();

        var capabilitiesByTarget = result.Capabilities
            .GroupBy(c => c.TargetTypeId ?? "(global)")
            .OrderBy(g => g.Key);

        foreach (var group in capabilitiesByTarget)
        {
            sb.AppendLine(CultureInfo.InvariantCulture, $"// Target: {group.Key}");
            sb.AppendLine("// {");
            foreach (var capability in group.OrderBy(c => c.MethodName))
            {
                WriteCapability(sb, capability);
            }
            sb.AppendLine("// }");
            sb.AppendLine();
        }

        // Output diagnostics if any
        if (result.Diagnostics.Count > 0)
        {
            sb.AppendLine("// Diagnostics");
            sb.AppendLine("// -----------");
            foreach (var diagnostic in result.Diagnostics)
            {
                sb.AppendLine(CultureInfo.InvariantCulture, $"// [{diagnostic.Severity}] {diagnostic.Message}");
                if (diagnostic.Location != null)
                {
                    sb.AppendLine(CultureInfo.InvariantCulture, $"//   Location: {diagnostic.Location}");
                }
            }
        }

        return sb.ToString();
    }

    private static void WriteCapability(StringBuilder sb, AtsCapabilityInfo capability)
    {
        sb.AppendLine(CultureInfo.InvariantCulture, $"//   {capability.CapabilityId}");
        if (!string.IsNullOrEmpty(capability.Description))
        {
            sb.AppendLine(CultureInfo.InvariantCulture, $"//     Description: {capability.Description}");
        }
        sb.AppendLine(CultureInfo.InvariantCulture, $"//     Kind: {capability.CapabilityKind}");

        // Parameters
        if (capability.Parameters.Count > 0)
        {
            sb.Append("//     Parameters: (");
            var paramStrings = new List<string>();
            foreach (var param in capability.Parameters)
            {
                var optional = param.IsOptional ? "?" : "";
                var nullable = param.IsNullable ? "?" : "";
                var typeId = param.Type?.TypeId ?? "unknown";
                paramStrings.Add($"{param.Name}{optional}: {typeId}{nullable}");
            }
            sb.Append(string.Join(", ", paramStrings));
            sb.AppendLine(")");
        }

        // Return type
        var returnTypeId = capability.ReturnType?.TypeId ?? "void";
        sb.AppendLine(CultureInfo.InvariantCulture, $"//     Returns: {returnTypeId}");
    }

    private static string GenerateJsonOutput(AtsCapabilityScanner.ScanResult result)
    {
        var sb = new StringBuilder();
        sb.AppendLine("{");

        // Handle types
        sb.AppendLine("  \"handleTypes\": [");
        var handleTypes = result.HandleTypes.OrderBy(t => t.AtsTypeId).ToList();
        for (var i = 0; i < handleTypes.Count; i++)
        {
            var type = handleTypes[i];
            sb.AppendLine("    {");
            sb.AppendLine(CultureInfo.InvariantCulture, $"      \"typeId\": \"{EscapeJson(type.AtsTypeId)}\",");
            sb.AppendLine(CultureInfo.InvariantCulture, $"      \"isInterface\": {type.IsInterface.ToString().ToLowerInvariant()},");
            sb.AppendLine(CultureInfo.InvariantCulture, $"      \"exposeProperties\": {type.HasExposeProperties.ToString().ToLowerInvariant()},");
            sb.AppendLine(CultureInfo.InvariantCulture, $"      \"exposeMethods\": {type.HasExposeMethods.ToString().ToLowerInvariant()}");
            sb.Append("    }");
            sb.AppendLine(i < handleTypes.Count - 1 ? "," : "");
        }
        sb.AppendLine("  ],");

        // DTO types
        sb.AppendLine("  \"dtoTypes\": [");
        var dtoTypes = result.DtoTypes.OrderBy(d => d.TypeId).ToList();
        for (var i = 0; i < dtoTypes.Count; i++)
        {
            var dto = dtoTypes[i];
            sb.AppendLine("    {");
            sb.AppendLine(CultureInfo.InvariantCulture, $"      \"typeId\": \"{EscapeJson(dto.TypeId)}\",");
            sb.AppendLine(CultureInfo.InvariantCulture, $"      \"name\": \"{EscapeJson(dto.Name)}\",");
            sb.AppendLine("      \"properties\": [");
            var props = dto.Properties.OrderBy(p => p.Name).ToList();
            for (var j = 0; j < props.Count; j++)
            {
                var prop = props[j];
                sb.AppendLine("        {");
                sb.AppendLine(CultureInfo.InvariantCulture, $"          \"name\": \"{EscapeJson(prop.Name)}\",");
                sb.AppendLine(CultureInfo.InvariantCulture, $"          \"type\": \"{EscapeJson(prop.Type?.TypeId ?? "unknown")}\",");
                sb.AppendLine(CultureInfo.InvariantCulture, $"          \"isOptional\": {prop.IsOptional.ToString().ToLowerInvariant()}");
                sb.Append("        }");
                sb.AppendLine(j < props.Count - 1 ? "," : "");
            }
            sb.AppendLine("      ]");
            sb.Append("    }");
            sb.AppendLine(i < dtoTypes.Count - 1 ? "," : "");
        }
        sb.AppendLine("  ],");

        // Enum types
        sb.AppendLine("  \"enumTypes\": [");
        var enumTypes = result.EnumTypes.OrderBy(e => e.TypeId).ToList();
        for (var i = 0; i < enumTypes.Count; i++)
        {
            var enumType = enumTypes[i];
            sb.AppendLine("    {");
            sb.AppendLine(CultureInfo.InvariantCulture, $"      \"typeId\": \"{EscapeJson(enumType.TypeId)}\",");
            sb.AppendLine(CultureInfo.InvariantCulture, $"      \"name\": \"{EscapeJson(enumType.Name)}\",");
            sb.AppendLine(CultureInfo.InvariantCulture, $"      \"values\": [{string.Join(", ", enumType.Values.Select(v => $"\"{EscapeJson(v)}\""))}]");
            sb.Append("    }");
            sb.AppendLine(i < enumTypes.Count - 1 ? "," : "");
        }
        sb.AppendLine("  ],");

        // Capabilities
        sb.AppendLine("  \"capabilities\": [");
        var capabilities = result.Capabilities.OrderBy(c => c.CapabilityId).ToList();
        for (var i = 0; i < capabilities.Count; i++)
        {
            var capability = capabilities[i];
            sb.AppendLine("    {");
            sb.AppendLine(CultureInfo.InvariantCulture, $"      \"capabilityId\": \"{EscapeJson(capability.CapabilityId)}\",");
            sb.AppendLine(CultureInfo.InvariantCulture, $"      \"methodName\": \"{EscapeJson(capability.MethodName)}\",");
            if (!string.IsNullOrEmpty(capability.Description))
            {
                sb.AppendLine(CultureInfo.InvariantCulture, $"      \"description\": \"{EscapeJson(capability.Description)}\",");
            }
            sb.AppendLine(CultureInfo.InvariantCulture, $"      \"kind\": \"{capability.CapabilityKind}\",");
            if (capability.TargetTypeId != null)
            {
                sb.AppendLine(CultureInfo.InvariantCulture, $"      \"targetTypeId\": \"{EscapeJson(capability.TargetTypeId)}\",");
            }
            sb.AppendLine(CultureInfo.InvariantCulture, $"      \"returnType\": \"{EscapeJson(capability.ReturnType?.TypeId ?? "void")}\",");
            sb.AppendLine("      \"parameters\": [");
            for (var j = 0; j < capability.Parameters.Count; j++)
            {
                var param = capability.Parameters[j];
                sb.AppendLine("        {");
                sb.AppendLine(CultureInfo.InvariantCulture, $"          \"name\": \"{EscapeJson(param.Name)}\",");
                sb.AppendLine(CultureInfo.InvariantCulture, $"          \"type\": \"{EscapeJson(param.Type?.TypeId ?? "unknown")}\",");
                sb.AppendLine(CultureInfo.InvariantCulture, $"          \"isOptional\": {param.IsOptional.ToString().ToLowerInvariant()},");
                sb.AppendLine(CultureInfo.InvariantCulture, $"          \"isNullable\": {param.IsNullable.ToString().ToLowerInvariant()},");
                sb.AppendLine(CultureInfo.InvariantCulture, $"          \"isCallback\": {param.IsCallback.ToString().ToLowerInvariant()}");
                sb.Append("        }");
                sb.AppendLine(j < capability.Parameters.Count - 1 ? "," : "");
            }
            sb.AppendLine("      ]");
            sb.Append("    }");
            sb.AppendLine(i < capabilities.Count - 1 ? "," : "");
        }
        sb.AppendLine("  ]");

        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string EscapeJson(string value)
    {
        return value
            .Replace("\\", "\\\\")
            .Replace("\"", "\\\"")
            .Replace("\n", "\\n")
            .Replace("\r", "\\r")
            .Replace("\t", "\\t");
    }
}
