// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

syntax = "proto3";

package aspire.v1;

import "google/protobuf/struct.proto";
import "google/protobuf/timestamp.proto";

////////////////////////////////////////////

message ApplicationInformationRequest {
}

message ApplicationInformationResponse {
    string application_name = 1;
    string application_version = 2;
}

////////////////////////////////////////////

message ResourceCommandRequest {
    string command_type = 1;
    ResourceId resource_id = 2;
    // When present, this message must be shown to the user and their confirmation obtained
    // before sending the request for this command to be executed.
    optional string confirmation_message = 3;
    // Optional parameter that configures the command in some way.
    // Clients must return any value provided by the server when invoking
    // the command.
    optional google.protobuf.Value parameter = 4;
}

enum ResourceCommandResponseKind {
    UNDEFINED = 0;
    SUCCEEDED = 1;
    FAILED = 2;
    CANCELLED = 3;
}

message ResourceCommandResponse {
    ResourceCommandResponseKind kind = 1;
    optional string error_message = 2;
}

////////////////////////////////////////////

message ResourceType {
    // Unique name for the resource type. Equivalent to ResourceId.resource_type
    // If "display_name" is omitted, this value will be used in UIs.
    string unique_name = 1;

    // Display string for references to this type in UI. May be localized.
    // If this value is omitted, UIs will show "unique_name" instead.
    optional string display_name = 2;

    // Any commands that may be executed against resources of this type, avoiding
    // the need to copy the value to every Resource instance.
    //
    // Note that these commands must apply to matching resources at any time.
    //
    // If the set of commands changes over time, use the "commands" property
    // of the Resource itself.
    repeated ResourceCommandRequest commands = 3;
}

////////////////////////////////////////////

message EnvironmentVariable {
    string name = 1;
    optional string value = 2;
    bool is_from_spec = 3;
}

message Endpoint {
    string name = 1;
    optional string allocated_address = 2;
    optional int32 allocated_port = 3;
    optional string http_address = 4;
}

message StringArray {
    repeated string values = 1;
}

message AdditionalData {
    // Name of the data item, e.g. "id", "image", "path", ...
    string name = 1;
    // Optional namespace, e.g. "container", "executable", "project", ...
    optional string namespace = 2;
    // Optional display name, may be localized
    optional string display_name = 3;
    // The data value. May be null, a number, a string, a boolean, a dictionary of values (Struct), or a list of values (ValueList).
    google.protobuf.Value value = 4;
}

message ResourceId {
    string uid = 1;
    // TODO do we need resource_type to make unique names? if not, inline ResourceId type as string.
    string resource_type = 2;
}

// Models the full state of an resource (container, executable, project, etc) at a particular point in time.
message ResourceSnapshot {
    ResourceId resource_id = 1;
    string display_name = 2;
    optional string state = 3;
    optional google.protobuf.Timestamp created_at = 4;
    repeated EnvironmentVariable environment = 5;
    optional int32 expected_endpoints_count = 6;
    repeated Endpoint endpoints = 7;
    repeated ResourceCommandRequest commands = 8;

    // TODO potentially remove endpoints/env vars/anything that might not be general purpose

    // List of additional data, as name/value pairs.
    // For:
    // - Containers: image, container_id, ports
    // - Executables: process_id, executable_path, working_directory, arguments
    // - Projects: process_id, project_path
    repeated AdditionalData additional_data = 9;
}

////////////////////////////////////////////

// Models a snapshot of resource state
message WatchResourcesSnapshot {
    repeated ResourceSnapshot resources = 1;
    repeated ResourceType types = 2;
}

////////////////////////////////////////////

message ResourceDeletion {
    ResourceId resource_id = 1;
}

message WatchResourcesChange  {
    oneof kind {
        ResourceDeletion delete = 1;
        ResourceSnapshot upsert = 2;
    }
}

message WatchResourcesChanges {
    repeated WatchResourcesChange value = 1;
}

////////////////////////////////////////////

// Initiates a subscription for data about resources.
message WatchResourcesRequest {
    // True if the client is establishing this connection because a prior one closed unexpectedly.
    optional bool is_reconnect = 1;
}

// A message received from the server when watching resources. Has multiple types of payload.
message WatchResourcesUpdate {
    oneof kind {
        // Snapshot of current resource state. Received once upon connection, before any "changes".
        WatchResourcesSnapshot initial_snapshot = 1;
        // One or more deltas to apply.
        WatchResourcesChanges changes = 2;
    }
}

////////////////////////////////////////////

message ConsoleLogLine {
    string text = 1;
    // Indicates whether this line came from STDERR or not.
    optional bool is_error = 2;
}

// Initiates a subscription for the logs of a resource.
message WatchResourceConsoleLogsRequest {
    // Specifies the resource to watch logs from.
    ResourceId resource_id = 1;
}

// A message received from the server when watching resource logs.
// Contains potentially many lines to be appended to the log.
message WatchResourceConsoleLogsUpdate {
    repeated ConsoleLogLine log_lines = 1;
}

////////////////////////////////////////////

message StructuredLog {
    google.protobuf.Timestamp timestamp = 1;
    uint32 flags = 2;
    StructuredLogLevel level = 3;
    string application_name = 4;
    string message = 5;
    string span_id = 6;
    string trace_id = 7;
    optional string original_format = 8;
    optional string scope_name = 9;
}

// Maps to Microsoft.Extensions.Logging.LogLevel (in names, not numbers)
enum StructuredLogLevel {
    TRACE = 0;
    DEBUG = 1;
    INFORMATION = 2;
    WARNING = 3;
    ERROR = 4;
    CRITICAL = 5;
    NONE = 6;
}

enum StructuredLogFilterOperator {
    EQUALS = 0;
    CONTAINS = 1;
    GREATER_THAN = 2;
    LESS_THAN = 3;
    GREATER_THAN_OR_EQUAL = 4;
    LESS_THAN_OR_EQUAL = 5;
    NOT_EQUAL = 6;
    NOT_CONTAINS = 7;
}

message StructuredLogFilter {
    string field = 1;
    StructuredLogFilterOperator operator = 2;
    string value = 3;
}

// TODO send set of filter options to client somewhere (app info? log response? new endpoint?)
message StructuredLogFilterOption {
    string field = 1;
    repeated StructuredLogFilterOperator operators = 2;
    repeated string valid_values = 3;
}

////////////////////////////////////////////

message StructuredLogsRequest {
    // TODO need a way to make these available to the client (or to map them from resources)
    optional string application_service_id = 1;
    int32 start_index = 2;
    optional int32 count = 3;
    optional StructuredLogLevel level = 4;
    repeated StructuredLogFilter filters = 5;
}

message StructuredLogsResponse {
    repeated StructuredLog logs = 1;
    int32 total_item_count = 2;
}

////////////////////////////////////////////

service DashboardService {
    rpc GetApplicationInformation(ApplicationInformationRequest) returns (ApplicationInformationResponse);
    rpc WatchResources(WatchResourcesRequest) returns (stream WatchResourcesUpdate);
    rpc WatchResourceConsoleLogs(WatchResourceConsoleLogsRequest) returns (stream WatchResourceConsoleLogsUpdate);
    rpc GetStructuredLogs(StructuredLogsRequest) returns (StructuredLogsResponse);
    rpc ExecuteResourceCommand(ResourceCommandRequest) returns (ResourceCommandResponse);
}
