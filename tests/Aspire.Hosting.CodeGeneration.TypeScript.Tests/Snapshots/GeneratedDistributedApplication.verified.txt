{
  distributed-application.ts:
import { RemoteAppHostClient, registerCallback, DotNetProxy, ListProxy, wrapIfProxy } from './RemoteAppHostClient.js';

// Get socket path from environment variable (set by aspire run)
const socketPath = process.env.REMOTE_APP_HOST_SOCKET_PATH;
if (!socketPath) {
    throw new Error('REMOTE_APP_HOST_SOCKET_PATH environment variable not set. Please run with "aspire run".');
}

// Get auth token from environment variable (set by aspire run)
const authToken = process.env.ASPIRE_RPC_AUTH_TOKEN;
if (!authToken) {
    throw new Error('ASPIRE_RPC_AUTH_TOKEN environment variable not set. Please run with "aspire run".');
}

const client = new RemoteAppHostClient(socketPath);

export async function createBuilder(args: string[] = process.argv.slice(2)): Promise<DistributedApplicationBuilder> {
    console.log('Connecting to AppHost server...');

    while (true) {
      try {
        await client.connect();
        await client.authenticate(authToken!);
        await client.ping();
        console.log('Connected successfully!');
        break;
      } catch (error) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    const result = await client.invokeStaticMethod('Aspire.Hosting', 'Aspire.Hosting.DistributedApplication', 'CreateBuilder', {
      options: {
        Args: args,
        ProjectDirectory: process.cwd()
      }
    });

    if (result && typeof result === 'object' && '$id' in result) {
      return new DistributedApplicationBuilder(new DotNetProxy(result as any));
    }

    throw new Error('Failed to create DistributedApplicationBuilder');
}

export class DistributedApplication {
  private _appProxy: DotNetProxy | null = null;

  constructor(private builderProxy: DotNetProxy | null) {
  }

  async run() {
    // Build the application using invokeMethod
    const buildResult = await this.builderProxy?.invokeMethod('Build', {});

    // Store the app proxy for service resolution
    if (buildResult && typeof buildResult === 'object' && '$id' in buildResult) {
      this._appProxy = new DotNetProxy(buildResult as any);
    }

    // Run the application using invokeMethod
    const runPromise = this._appProxy?.invokeMethod('RunAsync', {});

    // Wait for either Ctrl+C, SIGTERM, or the connection to close
    await new Promise<void>((resolve) => {
      const shutdown = () => {
        console.log("\nStopping application...");
        // Fire-and-forget StopAsync - don't wait for it to complete
        // This is important for hot reload to be fast - the process is being restarted anyway
        this._appProxy?.invokeMethod('StopAsync', {}).catch(() => {});
        client.disconnect();
        resolve();
      };

      process.on("SIGINT", () => shutdown());
      process.on("SIGTERM", () => shutdown());

      client.onDisconnect(() => {
        resolve();
      });

      runPromise?.then(() => resolve()).catch(() => resolve());
    });

    process.exit(0);
  }

  async getServices(): Promise<ServiceProviderProxy> {
    if (!this._appProxy) {
      throw new Error('Application not yet running. Call run() first.');
    }
    const result = await this._appProxy.getProperty('Services');
    return result as ServiceProviderProxy;
  }

  async getResourceNotifications(): Promise<ResourceNotificationServiceProxy> {
    if (!this._appProxy) {
      throw new Error('Application not yet running. Call run() first.');
    }
    const result = await this._appProxy.getProperty('ResourceNotifications');
    return result as ResourceNotificationServiceProxy;
  }

  async getResourceCommands(): Promise<ResourceCommandServiceProxy> {
    if (!this._appProxy) {
      throw new Error('Application not yet running. Call run() first.');
    }
    const result = await this._appProxy.getProperty('ResourceCommands');
    return result as ResourceCommandServiceProxy;
  }
}

export enum EventDispatchBehavior {
  BlockingSequential = "BlockingSequential",
  BlockingConcurrent = "BlockingConcurrent",
  NonBlockingSequential = "NonBlockingSequential",
  NonBlockingConcurrent = "NonBlockingConcurrent"
}

export enum DistributedApplicationOperation {
  Run = "Run",
  Publish = "Publish"
}

export enum WaitBehavior {
  WaitOnResourceUnavailable = "WaitOnResourceUnavailable",
  StopOnResourceUnavailable = "StopOnResourceUnavailable"
}

export enum HealthStatus {
  Unhealthy = "Unhealthy",
  Degraded = "Degraded",
  Healthy = "Healthy"
}

export enum IconVariant {
  Regular = "Regular",
  Filled = "Filled"
}

/**
 * Proxy for ConfigurationManager.
 */
export class ConfigurationManagerProxy {
  constructor(private _proxy: DotNetProxy) {}

  get proxy(): DotNetProxy { return this._proxy; }

  async getItem(): Promise<string> {
    const result = await this._proxy.getProperty('Item');
    return result as string;
  }

  async getSources(): Promise<Array<any>> {
    const result = await this._proxy.getProperty('Sources');
    return result as Array<any>;
  }

  async getSection(key: string): Promise<any> {
    return await this._proxy.invokeMethod('GetSection', { key }) as any;
  }

  async getChildren(): Promise<Array<any>> {
    return await this._proxy.invokeMethod('GetChildren', {}) as Array<any>;
  }

  async dispose(): Promise<void> {
    await this._proxy.invokeMethod('Dispose', {});
  }
}

/**
 * Thenable wrapper for ConfigurationManagerProxy that enables fluent async chaining.
 * Usage: await someMethod().propertyOrMethod().anotherMethod();
 */
export class ConfigurationManagerProxyPromise implements PromiseLike<ConfigurationManagerProxy> {
  constructor(private _promise: Promise<ConfigurationManagerProxy>) {}

  then<TResult1 = ConfigurationManagerProxy, TResult2 = never>(
    onfulfilled?: ((value: ConfigurationManagerProxy) => TResult1 | PromiseLike<TResult1>) | null,
    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null
  ): PromiseLike<TResult1 | TResult2> {
    return this._promise.then(onfulfilled, onrejected);
  }

  /**
   * getItem (fluent chaining)
   */
  getItem(): Promise<string> {
    return this._promise.then(p => p.getItem());
  }

  /**
   * getSources (fluent chaining)
   */
  getSources(): Promise<Array<any>> {
    return this._promise.then(p => p.getSources());
  }

  /**
   * getSection (fluent chaining)
   */
  getSection(key: string): Promise<any> {
    return this._promise.then(p => p.getSection(key));
  }

  /**
   * getChildren (fluent chaining)
   */
  getChildren(): Promise<Array<any>> {
    return this._promise.then(p => p.getChildren());
  }
}

/**
 * Proxy for IHostEnvironment.
 */
export class HostEnvironmentProxy {
  constructor(private _proxy: DotNetProxy) {}

  get proxy(): DotNetProxy { return this._proxy; }

  async getEnvironmentName(): Promise<string> {
    const result = await this._proxy.getProperty('EnvironmentName');
    return result as string;
  }

  async getApplicationName(): Promise<string> {
    const result = await this._proxy.getProperty('ApplicationName');
    return result as string;
  }

  async getContentRootPath(): Promise<string> {
    const result = await this._proxy.getProperty('ContentRootPath');
    return result as string;
  }

  getContentRootFileProvider(): FileProviderProxyPromise {
    return new FileProviderProxyPromise(
      (async () => {
        const result = await this._proxy.getProperty('ContentRootFileProvider') as DotNetProxy;
        return new FileProviderProxy(result);
      })()
    );
  }
}

/**
 * Thenable wrapper for HostEnvironmentProxy that enables fluent async chaining.
 * Usage: await someMethod().propertyOrMethod().anotherMethod();
 */
export class HostEnvironmentProxyPromise implements PromiseLike<HostEnvironmentProxy> {
  constructor(private _promise: Promise<HostEnvironmentProxy>) {}

  then<TResult1 = HostEnvironmentProxy, TResult2 = never>(
    onfulfilled?: ((value: HostEnvironmentProxy) => TResult1 | PromiseLike<TResult1>) | null,
    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null
  ): PromiseLike<TResult1 | TResult2> {
    return this._promise.then(onfulfilled, onrejected);
  }

  /**
   * getEnvironmentName (fluent chaining)
   */
  getEnvironmentName(): Promise<string> {
    return this._promise.then(p => p.getEnvironmentName());
  }

  /**
   * getApplicationName (fluent chaining)
   */
  getApplicationName(): Promise<string> {
    return this._promise.then(p => p.getApplicationName());
  }

  /**
   * getContentRootPath (fluent chaining)
   */
  getContentRootPath(): Promise<string> {
    return this._promise.then(p => p.getContentRootPath());
  }

  /**
   * getContentRootFileProvider (fluent chaining)
   */
  getContentRootFileProvider(): FileProviderProxyPromise {
    return new FileProviderProxyPromise(
      this._promise.then(p => p.getContentRootFileProvider())
    );
  }
}

/**
 * Proxy for IServiceCollection.
 */
export class ServiceCollectionProxy {
  constructor(private _proxy: DotNetProxy) {}

  get proxy(): DotNetProxy { return this._proxy; }
}

/**
 * Thenable wrapper for ServiceCollectionProxy that enables fluent async chaining.
 * Usage: await someMethod().propertyOrMethod().anotherMethod();
 */
export class ServiceCollectionProxyPromise implements PromiseLike<ServiceCollectionProxy> {
  constructor(private _promise: Promise<ServiceCollectionProxy>) {}

  then<TResult1 = ServiceCollectionProxy, TResult2 = never>(
    onfulfilled?: ((value: ServiceCollectionProxy) => TResult1 | PromiseLike<TResult1>) | null,
    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null
  ): PromiseLike<TResult1 | TResult2> {
    return this._promise.then(onfulfilled, onrejected);
  }
}

/**
 * Proxy for IDistributedApplicationEventing.
 */
export class DistributedApplicationEventingProxy {
  constructor(private _proxy: DotNetProxy) {}

  get proxy(): DotNetProxy { return this._proxy; }

  async subscribe(callback: (p0: any, p1: CancellationTokenProxy) => Promise<void>): Promise<any> {
    return await this._proxy.invokeMethod('Subscribe', { callback: registerCallback(callback) }) as any;
  }

  async subscribe2(resource: any, callback: (p0: any, p1: CancellationTokenProxy) => Promise<void>): Promise<any> {
    return await this._proxy.invokeMethod('Subscribe', { resource, callback: registerCallback(callback) }) as any;
  }

  async unsubscribe(subscription: any): Promise<void> {
    await this._proxy.invokeMethod('Unsubscribe', { subscription });
  }

  async publishAsync(event: any, cancellationToken: CancellationTokenProxy): Promise<any> {
    return await this._proxy.invokeMethod('PublishAsync', { event, cancellationToken }) as any;
  }

  async publishAsync2(event: any, dispatchBehavior: EventDispatchBehavior, cancellationToken: CancellationTokenProxy): Promise<any> {
    return await this._proxy.invokeMethod('PublishAsync', { event, dispatchBehavior, cancellationToken }) as any;
  }
}

/**
 * Thenable wrapper for DistributedApplicationEventingProxy that enables fluent async chaining.
 * Usage: await someMethod().propertyOrMethod().anotherMethod();
 */
export class DistributedApplicationEventingProxyPromise implements PromiseLike<DistributedApplicationEventingProxy> {
  constructor(private _promise: Promise<DistributedApplicationEventingProxy>) {}

  then<TResult1 = DistributedApplicationEventingProxy, TResult2 = never>(
    onfulfilled?: ((value: DistributedApplicationEventingProxy) => TResult1 | PromiseLike<TResult1>) | null,
    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null
  ): PromiseLike<TResult1 | TResult2> {
    return this._promise.then(onfulfilled, onrejected);
  }

  /**
   * subscribe (fluent chaining)
   */
  subscribe(callback: (p0: any, p1: CancellationTokenProxy) => Promise<void>): Promise<any> {
    return this._promise.then(p => p.subscribe(callback));
  }

  /**
   * subscribe2 (fluent chaining)
   */
  subscribe2(resource: any, callback: (p0: any, p1: CancellationTokenProxy) => Promise<void>): Promise<any> {
    return this._promise.then(p => p.subscribe2(resource, callback));
  }

  /**
   * publishAsync (fluent chaining)
   */
  publishAsync(event: any, cancellationToken: CancellationTokenProxy): Promise<any> {
    return this._promise.then(p => p.publishAsync(event, cancellationToken));
  }

  /**
   * publishAsync2 (fluent chaining)
   */
  publishAsync2(event: any, dispatchBehavior: EventDispatchBehavior, cancellationToken: CancellationTokenProxy): Promise<any> {
    return this._promise.then(p => p.publishAsync2(event, dispatchBehavior, cancellationToken));
  }
}

/**
 * Proxy for DistributedApplicationExecutionContext.
 */
export class DistributedApplicationExecutionContextProxy {
  constructor(private _proxy: DotNetProxy) {}

  get proxy(): DotNetProxy { return this._proxy; }

  async getPublisherName(): Promise<string> {
    const result = await this._proxy.getProperty('PublisherName');
    return result as string;
  }

  async getOperation(): Promise<DistributedApplicationOperation> {
    const result = await this._proxy.getProperty('Operation');
    return result as DistributedApplicationOperation;
  }

  getServiceProvider(): ServiceProviderProxyPromise {
    return new ServiceProviderProxyPromise(
      (async () => {
        const result = await this._proxy.getProperty('ServiceProvider') as DotNetProxy;
        return new ServiceProviderProxy(result);
      })()
    );
  }

  async getIsPublishMode(): Promise<boolean> {
    const result = await this._proxy.getProperty('IsPublishMode');
    return result as boolean;
  }

  async getIsRunMode(): Promise<boolean> {
    const result = await this._proxy.getProperty('IsRunMode');
    return result as boolean;
  }
}

/**
 * Thenable wrapper for DistributedApplicationExecutionContextProxy that enables fluent async chaining.
 * Usage: await someMethod().propertyOrMethod().anotherMethod();
 */
export class DistributedApplicationExecutionContextProxyPromise implements PromiseLike<DistributedApplicationExecutionContextProxy> {
  constructor(private _promise: Promise<DistributedApplicationExecutionContextProxy>) {}

  then<TResult1 = DistributedApplicationExecutionContextProxy, TResult2 = never>(
    onfulfilled?: ((value: DistributedApplicationExecutionContextProxy) => TResult1 | PromiseLike<TResult1>) | null,
    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null
  ): PromiseLike<TResult1 | TResult2> {
    return this._promise.then(onfulfilled, onrejected);
  }

  /**
   * getPublisherName (fluent chaining)
   */
  getPublisherName(): Promise<string> {
    return this._promise.then(p => p.getPublisherName());
  }

  /**
   * getOperation (fluent chaining)
   */
  getOperation(): Promise<DistributedApplicationOperation> {
    return this._promise.then(p => p.getOperation());
  }

  /**
   * getServiceProvider (fluent chaining)
   */
  getServiceProvider(): ServiceProviderProxyPromise {
    return new ServiceProviderProxyPromise(
      this._promise.then(p => p.getServiceProvider())
    );
  }

  /**
   * getIsPublishMode (fluent chaining)
   */
  getIsPublishMode(): Promise<boolean> {
    return this._promise.then(p => p.getIsPublishMode());
  }

  /**
   * getIsRunMode (fluent chaining)
   */
  getIsRunMode(): Promise<boolean> {
    return this._promise.then(p => p.getIsRunMode());
  }
}

/**
 * Proxy for IResourceCollection.
 */
export class ResourceCollectionProxy {
  constructor(private _proxy: DotNetProxy) {}

  get proxy(): DotNetProxy { return this._proxy; }
}

/**
 * Thenable wrapper for ResourceCollectionProxy that enables fluent async chaining.
 * Usage: await someMethod().propertyOrMethod().anotherMethod();
 */
export class ResourceCollectionProxyPromise implements PromiseLike<ResourceCollectionProxy> {
  constructor(private _promise: Promise<ResourceCollectionProxy>) {}

  then<TResult1 = ResourceCollectionProxy, TResult2 = never>(
    onfulfilled?: ((value: ResourceCollectionProxy) => TResult1 | PromiseLike<TResult1>) | null,
    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null
  ): PromiseLike<TResult1 | TResult2> {
    return this._promise.then(onfulfilled, onrejected);
  }
}

/**
 * Proxy for IDistributedApplicationPipeline.
 */
export class DistributedApplicationPipelineProxy {
  constructor(private _proxy: DotNetProxy) {}

  get proxy(): DotNetProxy { return this._proxy; }

  async addStep(step: any): Promise<void> {
    await this._proxy.invokeMethod('AddStep', { step });
  }

  async addStep2(name: string, action: (p0: PipelineStepContextProxy) => Promise<void>, dependsOn: any, requiredBy: any): Promise<void> {
    await this._proxy.invokeMethod('AddStep', { name, action: registerCallback(action), dependsOn, requiredBy });
  }

  async addPipelineConfiguration(callback: (p0: PipelineConfigurationContextProxy) => Promise<void>): Promise<void> {
    await this._proxy.invokeMethod('AddPipelineConfiguration', { callback: registerCallback(callback) });
  }

  async executeAsync(context: any): Promise<any> {
    return await this._proxy.invokeMethod('ExecuteAsync', { context }) as any;
  }
}

/**
 * Thenable wrapper for DistributedApplicationPipelineProxy that enables fluent async chaining.
 * Usage: await someMethod().propertyOrMethod().anotherMethod();
 */
export class DistributedApplicationPipelineProxyPromise implements PromiseLike<DistributedApplicationPipelineProxy> {
  constructor(private _promise: Promise<DistributedApplicationPipelineProxy>) {}

  then<TResult1 = DistributedApplicationPipelineProxy, TResult2 = never>(
    onfulfilled?: ((value: DistributedApplicationPipelineProxy) => TResult1 | PromiseLike<TResult1>) | null,
    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null
  ): PromiseLike<TResult1 | TResult2> {
    return this._promise.then(onfulfilled, onrejected);
  }

  /**
   * executeAsync (fluent chaining)
   */
  executeAsync(context: any): Promise<any> {
    return this._promise.then(p => p.executeAsync(context));
  }
}

/**
 * Proxy for IFileSystemService.
 */
export class FileSystemServiceProxy {
  constructor(private _proxy: DotNetProxy) {}

  get proxy(): DotNetProxy { return this._proxy; }

  getTempDirectory(): TempFileSystemServiceProxyPromise {
    return new TempFileSystemServiceProxyPromise(
      (async () => {
        const result = await this._proxy.getProperty('TempDirectory') as DotNetProxy;
        return new TempFileSystemServiceProxy(result);
      })()
    );
  }
}

/**
 * Thenable wrapper for FileSystemServiceProxy that enables fluent async chaining.
 * Usage: await someMethod().propertyOrMethod().anotherMethod();
 */
export class FileSystemServiceProxyPromise implements PromiseLike<FileSystemServiceProxy> {
  constructor(private _promise: Promise<FileSystemServiceProxy>) {}

  then<TResult1 = FileSystemServiceProxy, TResult2 = never>(
    onfulfilled?: ((value: FileSystemServiceProxy) => TResult1 | PromiseLike<TResult1>) | null,
    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null
  ): PromiseLike<TResult1 | TResult2> {
    return this._promise.then(onfulfilled, onrejected);
  }

  /**
   * getTempDirectory (fluent chaining)
   */
  getTempDirectory(): TempFileSystemServiceProxyPromise {
    return new TempFileSystemServiceProxyPromise(
      this._promise.then(p => p.getTempDirectory())
    );
  }
}

/**
 * Proxy for IUserSecretsManager.
 */
export class UserSecretsManagerProxy {
  constructor(private _proxy: DotNetProxy) {}

  get proxy(): DotNetProxy { return this._proxy; }

  async getFilePath(): Promise<string> {
    const result = await this._proxy.getProperty('FilePath');
    return result as string;
  }

  async trySetSecret(name: string, value: string): Promise<boolean> {
    return await this._proxy.invokeMethod('TrySetSecret', { name, value }) as boolean;
  }

  async getOrSetSecret(configuration: any, name: string, valueGenerator: () => string | Promise<string>): Promise<void> {
    await this._proxy.invokeMethod('GetOrSetSecret', { configuration, name, valueGenerator: registerCallback(valueGenerator) });
  }

  async saveStateAsync(state: any, cancellationToken: CancellationTokenProxy): Promise<any> {
    return await this._proxy.invokeMethod('SaveStateAsync', { state, cancellationToken }) as any;
  }
}

/**
 * Thenable wrapper for UserSecretsManagerProxy that enables fluent async chaining.
 * Usage: await someMethod().propertyOrMethod().anotherMethod();
 */
export class UserSecretsManagerProxyPromise implements PromiseLike<UserSecretsManagerProxy> {
  constructor(private _promise: Promise<UserSecretsManagerProxy>) {}

  then<TResult1 = UserSecretsManagerProxy, TResult2 = never>(
    onfulfilled?: ((value: UserSecretsManagerProxy) => TResult1 | PromiseLike<TResult1>) | null,
    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null
  ): PromiseLike<TResult1 | TResult2> {
    return this._promise.then(onfulfilled, onrejected);
  }

  /**
   * getFilePath (fluent chaining)
   */
  getFilePath(): Promise<string> {
    return this._promise.then(p => p.getFilePath());
  }

  /**
   * trySetSecret (fluent chaining)
   */
  trySetSecret(name: string, value: string): Promise<boolean> {
    return this._promise.then(p => p.trySetSecret(name, value));
  }

  /**
   * saveStateAsync (fluent chaining)
   */
  saveStateAsync(state: any, cancellationToken: CancellationTokenProxy): Promise<any> {
    return this._promise.then(p => p.saveStateAsync(state, cancellationToken));
  }
}

/**
 * Proxy for IServiceProvider.
 */
export class ServiceProviderProxy {
  constructor(private _proxy: DotNetProxy) {}

  get proxy(): DotNetProxy { return this._proxy; }

  async getService(serviceType: any): Promise<any> {
    return await this._proxy.invokeMethod('GetService', { serviceType }) as any;
  }
}

/**
 * Thenable wrapper for ServiceProviderProxy that enables fluent async chaining.
 * Usage: await someMethod().propertyOrMethod().anotherMethod();
 */
export class ServiceProviderProxyPromise implements PromiseLike<ServiceProviderProxy> {
  constructor(private _promise: Promise<ServiceProviderProxy>) {}

  then<TResult1 = ServiceProviderProxy, TResult2 = never>(
    onfulfilled?: ((value: ServiceProviderProxy) => TResult1 | PromiseLike<TResult1>) | null,
    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null
  ): PromiseLike<TResult1 | TResult2> {
    return this._promise.then(onfulfilled, onrejected);
  }

  /**
   * getService (fluent chaining)
   */
  getService(serviceType: any): Promise<any> {
    return this._promise.then(p => p.getService(serviceType));
  }
}

/**
 * Proxy for ResourceNotificationService.
 */
export class ResourceNotificationServiceProxy {
  constructor(private _proxy: DotNetProxy) {}

  get proxy(): DotNetProxy { return this._proxy; }

  async waitForResourceAsync(resourceName: string, targetState: string, cancellationToken: CancellationTokenProxy): Promise<any> {
    return await this._proxy.invokeMethod('WaitForResourceAsync', { resourceName, targetState, cancellationToken }) as any;
  }

  async waitForResourceAsync2(resourceName: string, targetStates: Array<string>, cancellationToken: CancellationTokenProxy): Promise<any> {
    return await this._proxy.invokeMethod('WaitForResourceAsync', { resourceName, targetStates, cancellationToken }) as any;
  }

  async waitForResourceAsync3(resourceName: string, predicate: (p0: ResourceEventProxy) => boolean | Promise<boolean>, cancellationToken: CancellationTokenProxy): Promise<any> {
    return await this._proxy.invokeMethod('WaitForResourceAsync', { resourceName, predicate: registerCallback(predicate), cancellationToken }) as any;
  }

  async waitForResourceHealthyAsync(resourceName: string, cancellationToken: CancellationTokenProxy): Promise<any> {
    return await this._proxy.invokeMethod('WaitForResourceHealthyAsync', { resourceName, cancellationToken }) as any;
  }

  async waitForResourceHealthyAsync2(resourceName: string, waitBehavior: WaitBehavior, cancellationToken: CancellationTokenProxy): Promise<any> {
    return await this._proxy.invokeMethod('WaitForResourceHealthyAsync', { resourceName, waitBehavior, cancellationToken }) as any;
  }

  async waitForDependenciesAsync(resource: any, cancellationToken: CancellationTokenProxy): Promise<any> {
    return await this._proxy.invokeMethod('WaitForDependenciesAsync', { resource, cancellationToken }) as any;
  }

  async tryGetCurrentState(resourceId: string, resourceEvent: ResourceEventProxy): Promise<boolean> {
    return await this._proxy.invokeMethod('TryGetCurrentState', { resourceId, resourceEvent }) as boolean;
  }

  async watchAsync(cancellationToken: CancellationTokenProxy): Promise<any> {
    return await this._proxy.invokeMethod('WatchAsync', { cancellationToken }) as any;
  }

  async publishUpdateAsync(resource: any, stateFactory: (p0: CustomResourceSnapshotProxy) => CustomResourceSnapshotProxy | Promise<CustomResourceSnapshotProxy>): Promise<any> {
    return await this._proxy.invokeMethod('PublishUpdateAsync', { resource, stateFactory: registerCallback(stateFactory) }) as any;
  }

  async publishUpdateAsync2(resource: any, resourceId: string, stateFactory: (p0: CustomResourceSnapshotProxy) => CustomResourceSnapshotProxy | Promise<CustomResourceSnapshotProxy>): Promise<any> {
    return await this._proxy.invokeMethod('PublishUpdateAsync', { resource, resourceId, stateFactory: registerCallback(stateFactory) }) as any;
  }

  async dispose(): Promise<void> {
    await this._proxy.invokeMethod('Dispose', {});
  }
}

/**
 * Thenable wrapper for ResourceNotificationServiceProxy that enables fluent async chaining.
 * Usage: await someMethod().propertyOrMethod().anotherMethod();
 */
export class ResourceNotificationServiceProxyPromise implements PromiseLike<ResourceNotificationServiceProxy> {
  constructor(private _promise: Promise<ResourceNotificationServiceProxy>) {}

  then<TResult1 = ResourceNotificationServiceProxy, TResult2 = never>(
    onfulfilled?: ((value: ResourceNotificationServiceProxy) => TResult1 | PromiseLike<TResult1>) | null,
    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null
  ): PromiseLike<TResult1 | TResult2> {
    return this._promise.then(onfulfilled, onrejected);
  }

  /**
   * waitForResourceAsync (fluent chaining)
   */
  waitForResourceAsync(resourceName: string, targetState: string, cancellationToken: CancellationTokenProxy): Promise<any> {
    return this._promise.then(p => p.waitForResourceAsync(resourceName, targetState, cancellationToken));
  }

  /**
   * waitForResourceAsync2 (fluent chaining)
   */
  waitForResourceAsync2(resourceName: string, targetStates: Array<string>, cancellationToken: CancellationTokenProxy): Promise<any> {
    return this._promise.then(p => p.waitForResourceAsync2(resourceName, targetStates, cancellationToken));
  }

  /**
   * waitForResourceAsync3 (fluent chaining)
   */
  waitForResourceAsync3(resourceName: string, predicate: (p0: ResourceEventProxy) => boolean | Promise<boolean>, cancellationToken: CancellationTokenProxy): Promise<any> {
    return this._promise.then(p => p.waitForResourceAsync3(resourceName, predicate, cancellationToken));
  }

  /**
   * waitForResourceHealthyAsync (fluent chaining)
   */
  waitForResourceHealthyAsync(resourceName: string, cancellationToken: CancellationTokenProxy): Promise<any> {
    return this._promise.then(p => p.waitForResourceHealthyAsync(resourceName, cancellationToken));
  }

  /**
   * waitForResourceHealthyAsync2 (fluent chaining)
   */
  waitForResourceHealthyAsync2(resourceName: string, waitBehavior: WaitBehavior, cancellationToken: CancellationTokenProxy): Promise<any> {
    return this._promise.then(p => p.waitForResourceHealthyAsync2(resourceName, waitBehavior, cancellationToken));
  }

  /**
   * waitForDependenciesAsync (fluent chaining)
   */
  waitForDependenciesAsync(resource: any, cancellationToken: CancellationTokenProxy): Promise<any> {
    return this._promise.then(p => p.waitForDependenciesAsync(resource, cancellationToken));
  }

  /**
   * tryGetCurrentState (fluent chaining)
   */
  tryGetCurrentState(resourceId: string, resourceEvent: ResourceEventProxy): Promise<boolean> {
    return this._promise.then(p => p.tryGetCurrentState(resourceId, resourceEvent));
  }

  /**
   * watchAsync (fluent chaining)
   */
  watchAsync(cancellationToken: CancellationTokenProxy): Promise<any> {
    return this._promise.then(p => p.watchAsync(cancellationToken));
  }

  /**
   * publishUpdateAsync (fluent chaining)
   */
  publishUpdateAsync(resource: any, stateFactory: (p0: CustomResourceSnapshotProxy) => CustomResourceSnapshotProxy | Promise<CustomResourceSnapshotProxy>): Promise<any> {
    return this._promise.then(p => p.publishUpdateAsync(resource, stateFactory));
  }

  /**
   * publishUpdateAsync2 (fluent chaining)
   */
  publishUpdateAsync2(resource: any, resourceId: string, stateFactory: (p0: CustomResourceSnapshotProxy) => CustomResourceSnapshotProxy | Promise<CustomResourceSnapshotProxy>): Promise<any> {
    return this._promise.then(p => p.publishUpdateAsync2(resource, resourceId, stateFactory));
  }
}

/**
 * Proxy for ResourceCommandService.
 */
export class ResourceCommandServiceProxy {
  constructor(private _proxy: DotNetProxy) {}

  get proxy(): DotNetProxy { return this._proxy; }

  async executeCommandAsync(resourceId: string, commandName: string, cancellationToken: CancellationTokenProxy): Promise<any> {
    return await this._proxy.invokeMethod('ExecuteCommandAsync', { resourceId, commandName, cancellationToken }) as any;
  }

  async executeCommandAsync2(resource: any, commandName: string, cancellationToken: CancellationTokenProxy): Promise<any> {
    return await this._proxy.invokeMethod('ExecuteCommandAsync', { resource, commandName, cancellationToken }) as any;
  }
}

/**
 * Thenable wrapper for ResourceCommandServiceProxy that enables fluent async chaining.
 * Usage: await someMethod().propertyOrMethod().anotherMethod();
 */
export class ResourceCommandServiceProxyPromise implements PromiseLike<ResourceCommandServiceProxy> {
  constructor(private _promise: Promise<ResourceCommandServiceProxy>) {}

  then<TResult1 = ResourceCommandServiceProxy, TResult2 = never>(
    onfulfilled?: ((value: ResourceCommandServiceProxy) => TResult1 | PromiseLike<TResult1>) | null,
    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null
  ): PromiseLike<TResult1 | TResult2> {
    return this._promise.then(onfulfilled, onrejected);
  }

  /**
   * executeCommandAsync (fluent chaining)
   */
  executeCommandAsync(resourceId: string, commandName: string, cancellationToken: CancellationTokenProxy): Promise<any> {
    return this._promise.then(p => p.executeCommandAsync(resourceId, commandName, cancellationToken));
  }

  /**
   * executeCommandAsync2 (fluent chaining)
   */
  executeCommandAsync2(resource: any, commandName: string, cancellationToken: CancellationTokenProxy): Promise<any> {
    return this._promise.then(p => p.executeCommandAsync2(resource, commandName, cancellationToken));
  }
}

/**
 * Proxy for IFileProvider.
 */
export class FileProviderProxy {
  constructor(private _proxy: DotNetProxy) {}

  get proxy(): DotNetProxy { return this._proxy; }

  async getFileInfo(subpath: string): Promise<any> {
    return await this._proxy.invokeMethod('GetFileInfo', { subpath }) as any;
  }

  async getDirectoryContents(subpath: string): Promise<any> {
    return await this._proxy.invokeMethod('GetDirectoryContents', { subpath }) as any;
  }

  async watch(filter: string): Promise<any> {
    return await this._proxy.invokeMethod('Watch', { filter }) as any;
  }
}

/**
 * Thenable wrapper for FileProviderProxy that enables fluent async chaining.
 * Usage: await someMethod().propertyOrMethod().anotherMethod();
 */
export class FileProviderProxyPromise implements PromiseLike<FileProviderProxy> {
  constructor(private _promise: Promise<FileProviderProxy>) {}

  then<TResult1 = FileProviderProxy, TResult2 = never>(
    onfulfilled?: ((value: FileProviderProxy) => TResult1 | PromiseLike<TResult1>) | null,
    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null
  ): PromiseLike<TResult1 | TResult2> {
    return this._promise.then(onfulfilled, onrejected);
  }

  /**
   * getFileInfo (fluent chaining)
   */
  getFileInfo(subpath: string): Promise<any> {
    return this._promise.then(p => p.getFileInfo(subpath));
  }

  /**
   * getDirectoryContents (fluent chaining)
   */
  getDirectoryContents(subpath: string): Promise<any> {
    return this._promise.then(p => p.getDirectoryContents(subpath));
  }

  /**
   * watch (fluent chaining)
   */
  watch(filter: string): Promise<any> {
    return this._promise.then(p => p.watch(filter));
  }
}

/**
 * Proxy for ITempFileSystemService.
 */
export class TempFileSystemServiceProxy {
  constructor(private _proxy: DotNetProxy) {}

  get proxy(): DotNetProxy { return this._proxy; }

  async createTempSubdirectory(prefix: string): Promise<any> {
    return await this._proxy.invokeMethod('CreateTempSubdirectory', { prefix }) as any;
  }

  async createTempFile(fileName: string): Promise<any> {
    return await this._proxy.invokeMethod('CreateTempFile', { fileName }) as any;
  }
}

/**
 * Thenable wrapper for TempFileSystemServiceProxy that enables fluent async chaining.
 * Usage: await someMethod().propertyOrMethod().anotherMethod();
 */
export class TempFileSystemServiceProxyPromise implements PromiseLike<TempFileSystemServiceProxy> {
  constructor(private _promise: Promise<TempFileSystemServiceProxy>) {}

  then<TResult1 = TempFileSystemServiceProxy, TResult2 = never>(
    onfulfilled?: ((value: TempFileSystemServiceProxy) => TResult1 | PromiseLike<TResult1>) | null,
    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null
  ): PromiseLike<TResult1 | TResult2> {
    return this._promise.then(onfulfilled, onrejected);
  }

  /**
   * createTempSubdirectory (fluent chaining)
   */
  createTempSubdirectory(prefix: string): Promise<any> {
    return this._promise.then(p => p.createTempSubdirectory(prefix));
  }

  /**
   * createTempFile (fluent chaining)
   */
  createTempFile(fileName: string): Promise<any> {
    return this._promise.then(p => p.createTempFile(fileName));
  }
}

abstract class DistributedApplicationBuilderBase {
  constructor(protected _proxy: DotNetProxy) {}

  get proxy(): DotNetProxy { return this._proxy; }

  getConfiguration(): ConfigurationManagerProxyPromise {
    return new ConfigurationManagerProxyPromise(
      (async () => {
        const result = await this._proxy.getProperty('Configuration') as DotNetProxy;
        return new ConfigurationManagerProxy(result);
      })()
    );
  }

  async getAppHostDirectory(): Promise<string> {
    const result = await this._proxy.getProperty('AppHostDirectory');
    return result as string;
  }

  async getAppHostAssembly(): Promise<any> {
    const result = await this._proxy.getProperty('AppHostAssembly');
    return result as any;
  }

  getEnvironment(): HostEnvironmentProxyPromise {
    return new HostEnvironmentProxyPromise(
      (async () => {
        const result = await this._proxy.getProperty('Environment') as DotNetProxy;
        return new HostEnvironmentProxy(result);
      })()
    );
  }

  getServices(): ServiceCollectionProxyPromise {
    return new ServiceCollectionProxyPromise(
      (async () => {
        const result = await this._proxy.getProperty('Services') as DotNetProxy;
        return new ServiceCollectionProxy(result);
      })()
    );
  }

  getEventing(): DistributedApplicationEventingProxyPromise {
    return new DistributedApplicationEventingProxyPromise(
      (async () => {
        const result = await this._proxy.getProperty('Eventing') as DotNetProxy;
        return new DistributedApplicationEventingProxy(result);
      })()
    );
  }

  getExecutionContext(): DistributedApplicationExecutionContextProxyPromise {
    return new DistributedApplicationExecutionContextProxyPromise(
      (async () => {
        const result = await this._proxy.getProperty('ExecutionContext') as DotNetProxy;
        return new DistributedApplicationExecutionContextProxy(result);
      })()
    );
  }

  getResources(): ResourceCollectionProxyPromise {
    return new ResourceCollectionProxyPromise(
      (async () => {
        const result = await this._proxy.getProperty('Resources') as DotNetProxy;
        return new ResourceCollectionProxy(result);
      })()
    );
  }

  getPipeline(): DistributedApplicationPipelineProxyPromise {
    return new DistributedApplicationPipelineProxyPromise(
      (async () => {
        const result = await this._proxy.getProperty('Pipeline') as DotNetProxy;
        return new DistributedApplicationPipelineProxy(result);
      })()
    );
  }

  getFileSystemService(): FileSystemServiceProxyPromise {
    return new FileSystemServiceProxyPromise(
      (async () => {
        const result = await this._proxy.getProperty('FileSystemService') as DotNetProxy;
        return new FileSystemServiceProxy(result);
      })()
    );
  }

  getUserSecretsManager(): UserSecretsManagerProxyPromise {
    return new UserSecretsManagerProxyPromise(
      (async () => {
        const result = await this._proxy.getProperty('UserSecretsManager') as DotNetProxy;
        return new UserSecretsManagerProxy(result);
      })()
    );
  }

  build() {
    return new DistributedApplication(this._proxy);
  }
}
export class DistributedApplicationBuilder extends DistributedApplicationBuilderBase {

   /**
   * AddTestRedis
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> AddTestRedis(IDistributedApplicationBuilder builder, String name, Nullable<Int32> port)
   * @param {string} name C# Type: String
   * @param {number | null} port C# Type: Nullable<Int32>
   * @returns {TestRedisResourceBuilder} C# Type: IResourceBuilder<TestRedisResource>
   */
  /** @internal */
  async _addTestRedisInternal(name: string, port?: number | null) : Promise<TestRedisResourceBuilder> {
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'AddTestRedis', {builder: this._proxy, name: name, port: port || null});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestRedisResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('AddTestRedis did not return a marshalled object');
  };

  /**
   * AddTestRedis (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> AddTestRedis(IDistributedApplicationBuilder builder, String name, Nullable<Int32> port)
   */
  addTestRedis(name: string, port?: number | null): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(this._addTestRedisInternal(name, port));
  }

   /**
   * AddTestDatabase
   * @remarks C# Definition: IResourceBuilder<TestDatabaseResource> AddTestDatabase(IDistributedApplicationBuilder builder, String name, String databaseName)
   * @param {string} name C# Type: String
   * @param {string} databaseName C# Type: String
   * @returns {TestDatabaseResourceBuilder} C# Type: IResourceBuilder<TestDatabaseResource>
   */
  /** @internal */
  async _addTestDatabaseInternal(name: string, databaseName?: string) : Promise<TestDatabaseResourceBuilder> {
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'AddTestDatabase', {builder: this._proxy, name: name, databaseName: databaseName || null});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestDatabaseResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('AddTestDatabase did not return a marshalled object');
  };

  /**
   * AddTestDatabase (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestDatabaseResource> AddTestDatabase(IDistributedApplicationBuilder builder, String name, String databaseName)
   */
  addTestDatabase(name: string, databaseName?: string): TestDatabaseResourceBuilderPromise {
    return new TestDatabaseResourceBuilderPromise(this._addTestDatabaseInternal(name, databaseName));
  }
}

export class TestRedisResourceBuilder {
  constructor(protected _proxy: DotNetProxy) {}

  /** Gets the underlying proxy */
  get proxy(): DotNetProxy { return this._proxy; }

   /**
   * WithPersistence
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithPersistence(IResourceBuilder<TestRedisResource> builder, TestPersistenceMode mode)
   * @param {TestPersistenceMode} mode C# Type: TestPersistenceMode
   * @returns {TestRedisResourceBuilder} C# Type: IResourceBuilder<TestRedisResource>
   */
  /** @internal */
  async _withPersistenceInternal(mode?: TestPersistenceMode) : Promise<TestRedisResourceBuilder> {
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithPersistence', {builder: this._proxy, mode: mode || null});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestRedisResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithPersistence did not return a marshalled object');
  };

  /**
   * WithPersistence (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithPersistence(IResourceBuilder<TestRedisResource> builder, TestPersistenceMode mode)
   */
  withPersistence(mode?: TestPersistenceMode): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(this._withPersistenceInternal(mode));
  }

   /**
   * WithBuilderCallback
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithBuilderCallback(IResourceBuilder<TestRedisResource> builder, Action<IResourceBuilder<TestRedisResource>> configure)
   * @param {(p0: TestRedisResourceBuilder) => void | Promise<void>} configure C# Type: Action<IResourceBuilder<TestRedisResource>>
   * @returns {TestRedisResourceBuilder} C# Type: IResourceBuilder<TestRedisResource>
   */
  /** @internal */
  async _withBuilderCallbackInternal(configure?: (p0: TestRedisResourceBuilder) => void | Promise<void>) : Promise<TestRedisResourceBuilder> {
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithBuilderCallback', {builder: this._proxy, configure: configure ? registerCallback((arg: DotNetProxy) => configure!(new TestRedisResourceBuilder(arg))) : null});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestRedisResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithBuilderCallback did not return a marshalled object');
  };

  /**
   * WithBuilderCallback (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithBuilderCallback(IResourceBuilder<TestRedisResource> builder, Action<IResourceBuilder<TestRedisResource>> configure)
   */
  withBuilderCallback(configure?: (p0: TestRedisResourceBuilder) => void | Promise<void>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(this._withBuilderCallbackInternal(configure));
  }

   /**
   * AsConnectionString
   * @remarks C# Definition: IResourceBuilder<IResourceWithConnectionString> AsConnectionString(IResourceBuilder<TestRedisResource> builder)
   
   * @returns {IResourceWithConnectionStringBuilder} C# Type: IResourceBuilder<IResourceWithConnectionString>
   */
  /** @internal */
  async _asConnectionStringInternal() : Promise<IResourceWithConnectionStringBuilder> {
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'AsConnectionString', {builder: this._proxy, });
    if (result && typeof result === 'object' && '$id' in result) {
        return new IResourceWithConnectionStringBuilder(new DotNetProxy(result as any));
    }
    throw new Error('AsConnectionString did not return a marshalled object');
  };

  /**
   * AsConnectionString (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<IResourceWithConnectionString> AsConnectionString(IResourceBuilder<TestRedisResource> builder)
   */
  asConnectionString(): IResourceWithConnectionStringBuilderPromise {
    return new IResourceWithConnectionStringBuilderPromise(this._asConnectionStringInternal());
  }

   /**
   * WithCircularCallback
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithCircularCallback(IResourceBuilder<TestRedisResource> builder, Action<IResourceBuilder<TestRedisResource>> configure)
   * @param {(p0: TestRedisResourceBuilder) => void | Promise<void>} configure C# Type: Action<IResourceBuilder<TestRedisResource>>
   * @returns {TestRedisResourceBuilder} C# Type: IResourceBuilder<TestRedisResource>
   */
  /** @internal */
  async _withCircularCallbackInternal(configure: (p0: TestRedisResourceBuilder) => void | Promise<void>) : Promise<TestRedisResourceBuilder> {
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithCircularCallback', {builder: this._proxy, configure: registerCallback((arg: DotNetProxy) => configure(new TestRedisResourceBuilder(arg)))});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestRedisResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithCircularCallback did not return a marshalled object');
  };

  /**
   * WithCircularCallback (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithCircularCallback(IResourceBuilder<TestRedisResource> builder, Action<IResourceBuilder<TestRedisResource>> configure)
   */
  withCircularCallback(configure: (p0: TestRedisResourceBuilder) => void | Promise<void>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(this._withCircularCallbackInternal(configure));
  }

   /**
   * WithNestedCallback
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithNestedCallback(IResourceBuilder<TestRedisResource> builder, Action<Action<IResourceBuilder<TestRedisResource>>> outerConfigure)
   * @param {(p0: (p0: TestRedisResourceBuilder) => void | Promise<void>) => void | Promise<void>} outerConfigure C# Type: Action<Action<IResourceBuilder<TestRedisResource>>>
   * @returns {TestRedisResourceBuilder} C# Type: IResourceBuilder<TestRedisResource>
   */
  /** @internal */
  async _withNestedCallbackInternal(outerConfigure: (p0: (p0: TestRedisResourceBuilder) => void | Promise<void>) => void | Promise<void>) : Promise<TestRedisResourceBuilder> {
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithNestedCallback', {builder: this._proxy, outerConfigure: registerCallback(outerConfigure)});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestRedisResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithNestedCallback did not return a marshalled object');
  };

  /**
   * WithNestedCallback (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithNestedCallback(IResourceBuilder<TestRedisResource> builder, Action<Action<IResourceBuilder<TestRedisResource>>> outerConfigure)
   */
  withNestedCallback(outerConfigure: (p0: (p0: TestRedisResourceBuilder) => void | Promise<void>) => void | Promise<void>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(this._withNestedCallbackInternal(outerConfigure));
  }

   /**
   * WithAsyncCallback
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithAsyncCallback(IResourceBuilder<TestRedisResource> builder, Func<TestCallbackContext, Task> asyncCallback)
   * @param {(p0: TestCallbackContextProxy) => Promise<void>} asyncCallback C# Type: Func<TestCallbackContext, Task>
   * @returns {TestRedisResourceBuilder} C# Type: IResourceBuilder<TestRedisResource>
   */
  /** @internal */
  async _withAsyncCallbackInternal(asyncCallback: (p0: TestCallbackContextProxy) => Promise<void>) : Promise<TestRedisResourceBuilder> {
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithAsyncCallback', {builder: this._proxy, asyncCallback: registerCallback(asyncCallback)});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestRedisResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithAsyncCallback did not return a marshalled object');
  };

  /**
   * WithAsyncCallback (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithAsyncCallback(IResourceBuilder<TestRedisResource> builder, Func<TestCallbackContext, Task> asyncCallback)
   */
  withAsyncCallback(asyncCallback: (p0: TestCallbackContextProxy) => Promise<void>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(this._withAsyncCallbackInternal(asyncCallback));
  }

   /**
   * WithAsyncCallbackWithResult
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithAsyncCallbackWithResult(IResourceBuilder<TestRedisResource> builder, Func<TestCallbackContext, Task<Boolean>> asyncCallback)
   * @param {(p0: TestCallbackContextProxy) => Promise<boolean>} asyncCallback C# Type: Func<TestCallbackContext, Task<Boolean>>
   * @returns {TestRedisResourceBuilder} C# Type: IResourceBuilder<TestRedisResource>
   */
  /** @internal */
  async _withAsyncCallbackWithResultInternal(asyncCallback: (p0: TestCallbackContextProxy) => Promise<boolean>) : Promise<TestRedisResourceBuilder> {
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithAsyncCallbackWithResult', {builder: this._proxy, asyncCallback: registerCallback(asyncCallback)});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestRedisResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithAsyncCallbackWithResult did not return a marshalled object');
  };

  /**
   * WithAsyncCallbackWithResult (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithAsyncCallbackWithResult(IResourceBuilder<TestRedisResource> builder, Func<TestCallbackContext, Task<Boolean>> asyncCallback)
   */
  withAsyncCallbackWithResult(asyncCallback: (p0: TestCallbackContextProxy) => Promise<boolean>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(this._withAsyncCallbackWithResultInternal(asyncCallback));
  }

   /**
   * WithAsyncBuilderCallback
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithAsyncBuilderCallback(IResourceBuilder<TestRedisResource> builder, Func<IResourceBuilder<TestRedisResource>, Task> asyncConfigure)
   * @param {(p0: TestRedisResourceBuilder) => Promise<void>} asyncConfigure C# Type: Func<IResourceBuilder<TestRedisResource>, Task>
   * @returns {TestRedisResourceBuilder} C# Type: IResourceBuilder<TestRedisResource>
   */
  /** @internal */
  async _withAsyncBuilderCallbackInternal(asyncConfigure: (p0: TestRedisResourceBuilder) => Promise<void>) : Promise<TestRedisResourceBuilder> {
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithAsyncBuilderCallback', {builder: this._proxy, asyncConfigure: registerCallback(asyncConfigure)});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestRedisResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithAsyncBuilderCallback did not return a marshalled object');
  };

  /**
   * WithAsyncBuilderCallback (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithAsyncBuilderCallback(IResourceBuilder<TestRedisResource> builder, Func<IResourceBuilder<TestRedisResource>, Task> asyncConfigure)
   */
  withAsyncBuilderCallback(asyncConfigure: (p0: TestRedisResourceBuilder) => Promise<void>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(this._withAsyncBuilderCallbackInternal(asyncConfigure));
  }

   /**
   * WithTags
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithTags(IResourceBuilder<TestRedisResource> builder, String[] tags)
   * @param {Array<string>} tags C# Type: String[]
   * @returns {TestRedisResourceBuilder} C# Type: IResourceBuilder<TestRedisResource>
   */
  /** @internal */
  async _withTagsInternal(tags: Array<string>) : Promise<TestRedisResourceBuilder> {
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithTags', {builder: this._proxy, tags: tags});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestRedisResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithTags did not return a marshalled object');
  };

  /**
   * WithTags (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithTags(IResourceBuilder<TestRedisResource> builder, String[] tags)
   */
  withTags(tags: Array<string>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(this._withTagsInternal(tags));
  }

   /**
   * WithLabels
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithLabels(IResourceBuilder<TestRedisResource> builder, List<String> labels)
   * @param {Array<string>} labels C# Type: List<String>
   * @returns {TestRedisResourceBuilder} C# Type: IResourceBuilder<TestRedisResource>
   */
  /** @internal */
  async _withLabelsInternal(labels: Array<string>) : Promise<TestRedisResourceBuilder> {
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithLabels', {builder: this._proxy, labels: labels});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestRedisResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithLabels did not return a marshalled object');
  };

  /**
   * WithLabels (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithLabels(IResourceBuilder<TestRedisResource> builder, List<String> labels)
   */
  withLabels(labels: Array<string>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(this._withLabelsInternal(labels));
  }

   /**
   * WithMetadata
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithMetadata(IResourceBuilder<TestRedisResource> builder, Dictionary<String, String> metadata)
   * @param {Map<string, string>} metadata C# Type: Dictionary<String, String>
   * @returns {TestRedisResourceBuilder} C# Type: IResourceBuilder<TestRedisResource>
   */
  /** @internal */
  async _withMetadataInternal(metadata: Map<string, string>) : Promise<TestRedisResourceBuilder> {
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithMetadata', {builder: this._proxy, metadata: metadata});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestRedisResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithMetadata did not return a marshalled object');
  };

  /**
   * WithMetadata (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithMetadata(IResourceBuilder<TestRedisResource> builder, Dictionary<String, String> metadata)
   */
  withMetadata(metadata: Map<string, string>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(this._withMetadataInternal(metadata));
  }

   /**
   * WithItems
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithItems(IResourceBuilder<TestRedisResource> builder, IEnumerable<String> items)
   * @param {Array<string>} items C# Type: IEnumerable<String>
   * @returns {TestRedisResourceBuilder} C# Type: IResourceBuilder<TestRedisResource>
   */
  /** @internal */
  async _withItemsInternal(items: Array<string>) : Promise<TestRedisResourceBuilder> {
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithItems', {builder: this._proxy, items: items});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestRedisResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithItems did not return a marshalled object');
  };

  /**
   * WithItems (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithItems(IResourceBuilder<TestRedisResource> builder, IEnumerable<String> items)
   */
  withItems(items: Array<string>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(this._withItemsInternal(items));
  }

   /**
   * WithTimeout
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithTimeout(IResourceBuilder<TestRedisResource> builder, Nullable<Int32> timeoutSeconds)
   * @param {number | null} timeoutSeconds C# Type: Nullable<Int32>
   * @returns {TestRedisResourceBuilder} C# Type: IResourceBuilder<TestRedisResource>
   */
  /** @internal */
  async _withTimeoutInternal(timeoutSeconds?: number | null) : Promise<TestRedisResourceBuilder> {
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithTimeout', {builder: this._proxy, timeoutSeconds: timeoutSeconds || null});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestRedisResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithTimeout did not return a marshalled object');
  };

  /**
   * WithTimeout (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithTimeout(IResourceBuilder<TestRedisResource> builder, Nullable<Int32> timeoutSeconds)
   */
  withTimeout(timeoutSeconds?: number | null): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(this._withTimeoutInternal(timeoutSeconds));
  }

   /**
   * WithLimits
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithLimits(IResourceBuilder<TestRedisResource> builder, Nullable<Int32> maxConnections, Nullable<Double> memoryLimitMb, Nullable<Boolean> enableLogging)
   * @param {number | null} maxConnections C# Type: Nullable<Int32>
   * @param {number | null} memoryLimitMb C# Type: Nullable<Double>
   * @param {boolean | null} enableLogging C# Type: Nullable<Boolean>
   * @returns {TestRedisResourceBuilder} C# Type: IResourceBuilder<TestRedisResource>
   */
  /** @internal */
  async _withLimitsInternal(optionalArguments: WithLimitsArgs = new WithLimitsArgs()) : Promise<TestRedisResourceBuilder> {
    optionalArguments = Object.assign(new WithLimitsArgs(), optionalArguments);
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithLimits', {builder: this._proxy, maxConnections: optionalArguments?.maxConnections || null, memoryLimitMb: optionalArguments?.memoryLimitMb || null, enableLogging: optionalArguments?.enableLogging || null});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestRedisResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithLimits did not return a marshalled object');
  };

  /**
   * WithLimits (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithLimits(IResourceBuilder<TestRedisResource> builder, Nullable<Int32> maxConnections, Nullable<Double> memoryLimitMb, Nullable<Boolean> enableLogging)
   */
  withLimits(optionalArguments: WithLimitsArgs = new WithLimitsArgs()): TestRedisResourceBuilderPromise {
    optionalArguments = Object.assign(new WithLimitsArgs(), optionalArguments);
    return new TestRedisResourceBuilderPromise(this._withLimitsInternal(optionalArguments));
  }

   /**
   * WithExpiry
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithExpiry(IResourceBuilder<TestRedisResource> builder, TimeSpan expiry)
   * @param {number} expiry C# Type: TimeSpan
   * @returns {TestRedisResourceBuilder} C# Type: IResourceBuilder<TestRedisResource>
   */
  /** @internal */
  async _withExpiryInternal(expiry: number) : Promise<TestRedisResourceBuilder> {
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithExpiry', {builder: this._proxy, expiry: expiry});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestRedisResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithExpiry did not return a marshalled object');
  };

  /**
   * WithExpiry (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithExpiry(IResourceBuilder<TestRedisResource> builder, TimeSpan expiry)
   */
  withExpiry(expiry: number): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(this._withExpiryInternal(expiry));
  }

   /**
   * WithOptionalExpiry
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithOptionalExpiry(IResourceBuilder<TestRedisResource> builder, Nullable<TimeSpan> expiry)
   * @param {number | null} expiry C# Type: Nullable<TimeSpan>
   * @returns {TestRedisResourceBuilder} C# Type: IResourceBuilder<TestRedisResource>
   */
  /** @internal */
  async _withOptionalExpiryInternal(expiry?: number | null) : Promise<TestRedisResourceBuilder> {
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithOptionalExpiry', {builder: this._proxy, expiry: expiry || null});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestRedisResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithOptionalExpiry did not return a marshalled object');
  };

  /**
   * WithOptionalExpiry (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithOptionalExpiry(IResourceBuilder<TestRedisResource> builder, Nullable<TimeSpan> expiry)
   */
  withOptionalExpiry(expiry?: number | null): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(this._withOptionalExpiryInternal(expiry));
  }

   /**
   * WithTransform
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithTransform(IResourceBuilder<TestRedisResource> builder, Func<String, Int32, String> transform)
   * @param {(p0: string, p1: number) => string | Promise<string>} transform C# Type: Func<String, Int32, String>
   * @returns {TestRedisResourceBuilder} C# Type: IResourceBuilder<TestRedisResource>
   */
  /** @internal */
  async _withTransformInternal(transform: (p0: string, p1: number) => string | Promise<string>) : Promise<TestRedisResourceBuilder> {
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithTransform', {builder: this._proxy, transform: registerCallback(transform)});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestRedisResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithTransform did not return a marshalled object');
  };

  /**
   * WithTransform (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithTransform(IResourceBuilder<TestRedisResource> builder, Func<String, Int32, String> transform)
   */
  withTransform(transform: (p0: string, p1: number) => string | Promise<string>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(this._withTransformInternal(transform));
  }

   /**
   * WithMultiParamCallback
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithMultiParamCallback(IResourceBuilder<TestRedisResource> builder, Action<String, Int32, Boolean> callback)
   * @param {(p0: string, p1: number, p2: boolean) => void | Promise<void>} callback C# Type: Action<String, Int32, Boolean>
   * @returns {TestRedisResourceBuilder} C# Type: IResourceBuilder<TestRedisResource>
   */
  /** @internal */
  async _withMultiParamCallbackInternal(callback: (p0: string, p1: number, p2: boolean) => void | Promise<void>) : Promise<TestRedisResourceBuilder> {
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithMultiParamCallback', {builder: this._proxy, callback: registerCallback(callback)});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestRedisResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithMultiParamCallback did not return a marshalled object');
  };

  /**
   * WithMultiParamCallback (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithMultiParamCallback(IResourceBuilder<TestRedisResource> builder, Action<String, Int32, Boolean> callback)
   */
  withMultiParamCallback(callback: (p0: string, p1: number, p2: boolean) => void | Promise<void>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(this._withMultiParamCallbackInternal(callback));
  }

   /**
   * WithSetting
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithSetting(IResourceBuilder<TestRedisResource> builder, KeyValuePair<String, String> setting)
   * @param {any} setting C# Type: KeyValuePair<String, String>
   * @returns {TestRedisResourceBuilder} C# Type: IResourceBuilder<TestRedisResource>
   */
  /** @internal */
  async _withSettingInternal(setting: any) : Promise<TestRedisResourceBuilder> {
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithSetting', {builder: this._proxy, setting: setting});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestRedisResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithSetting did not return a marshalled object');
  };

  /**
   * WithSetting (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithSetting(IResourceBuilder<TestRedisResource> builder, KeyValuePair<String, String> setting)
   */
  withSetting(setting: any): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(this._withSettingInternal(setting));
  }

   /**
   * WithEndpointMapping
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithEndpointMapping(IResourceBuilder<TestRedisResource> builder, ValueTuple<String, Int32> endpoint)
   * @param {any} endpoint C# Type: ValueTuple<String, Int32>
   * @returns {TestRedisResourceBuilder} C# Type: IResourceBuilder<TestRedisResource>
   */
  /** @internal */
  async _withEndpointMappingInternal(endpoint: any) : Promise<TestRedisResourceBuilder> {
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithEndpointMapping', {builder: this._proxy, endpoint: endpoint});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestRedisResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithEndpointMapping did not return a marshalled object');
  };

  /**
   * WithEndpointMapping (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithEndpointMapping(IResourceBuilder<TestRedisResource> builder, ValueTuple<String, Int32> endpoint)
   */
  withEndpointMapping(endpoint: any): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(this._withEndpointMappingInternal(endpoint));
  }

   /**
   * WithProxyUrl
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithProxyUrl(IResourceBuilder<TestRedisResource> builder, Uri proxyUrl)
   * @param {string} proxyUrl C# Type: Uri
   * @returns {TestRedisResourceBuilder} C# Type: IResourceBuilder<TestRedisResource>
   */
  /** @internal */
  async _withProxyUrlInternal(proxyUrl: string) : Promise<TestRedisResourceBuilder> {
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithProxyUrl', {builder: this._proxy, proxyUrl: proxyUrl});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestRedisResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithProxyUrl did not return a marshalled object');
  };

  /**
   * WithProxyUrl (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithProxyUrl(IResourceBuilder<TestRedisResource> builder, Uri proxyUrl)
   */
  withProxyUrl(proxyUrl: string): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(this._withProxyUrlInternal(proxyUrl));
  }

   /**
   * WithCallbackContexts
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithCallbackContexts(IResourceBuilder<TestRedisResource> builder, TestCallbackContext[] contexts)
   * @param {Array<TestCallbackContextProxy>} contexts C# Type: TestCallbackContext[]
   * @returns {TestRedisResourceBuilder} C# Type: IResourceBuilder<TestRedisResource>
   */
  /** @internal */
  async _withCallbackContextsInternal(contexts: Array<TestCallbackContextProxy>) : Promise<TestRedisResourceBuilder> {
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithCallbackContexts', {builder: this._proxy, contexts: contexts});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestRedisResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithCallbackContexts did not return a marshalled object');
  };

  /**
   * WithCallbackContexts (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithCallbackContexts(IResourceBuilder<TestRedisResource> builder, TestCallbackContext[] contexts)
   */
  withCallbackContexts(contexts: Array<TestCallbackContextProxy>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(this._withCallbackContextsInternal(contexts));
  }

   /**
   * WithSimpleCallback
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithSimpleCallback(IResourceBuilder<TestRedisResource> builder, Action callback)
   * @param {() => void | Promise<void>} callback C# Type: Action
   * @returns {TestRedisResourceBuilder} C# Type: IResourceBuilder<TestRedisResource>
   */
  /** @internal */
  async _withSimpleCallbackInternal(callback: () => void | Promise<void>) : Promise<TestRedisResourceBuilder> {
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithSimpleCallback', {builder: this._proxy, callback: registerCallback(callback)});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestRedisResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithSimpleCallback did not return a marshalled object');
  };

  /**
   * WithSimpleCallback (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithSimpleCallback(IResourceBuilder<TestRedisResource> builder, Action callback)
   */
  withSimpleCallback(callback: () => void | Promise<void>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(this._withSimpleCallbackInternal(callback));
  }

   /**
   * WithValueProvider
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithValueProvider(IResourceBuilder<TestRedisResource> builder, Func<String> valueProvider)
   * @param {() => string | Promise<string>} valueProvider C# Type: Func<String>
   * @returns {TestRedisResourceBuilder} C# Type: IResourceBuilder<TestRedisResource>
   */
  /** @internal */
  async _withValueProviderInternal(valueProvider: () => string | Promise<string>) : Promise<TestRedisResourceBuilder> {
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithValueProvider', {builder: this._proxy, valueProvider: registerCallback(valueProvider)});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestRedisResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithValueProvider did not return a marshalled object');
  };

  /**
   * WithValueProvider (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithValueProvider(IResourceBuilder<TestRedisResource> builder, Func<String> valueProvider)
   */
  withValueProvider(valueProvider: () => string | Promise<string>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(this._withValueProviderInternal(valueProvider));
  }

   /**
   * WithAsyncValueProvider
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithAsyncValueProvider(IResourceBuilder<TestRedisResource> builder, Func<Task<String>> asyncValueProvider)
   * @param {() => Promise<string>} asyncValueProvider C# Type: Func<Task<String>>
   * @returns {TestRedisResourceBuilder} C# Type: IResourceBuilder<TestRedisResource>
   */
  /** @internal */
  async _withAsyncValueProviderInternal(asyncValueProvider: () => Promise<string>) : Promise<TestRedisResourceBuilder> {
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithAsyncValueProvider', {builder: this._proxy, asyncValueProvider: registerCallback(asyncValueProvider)});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestRedisResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithAsyncValueProvider did not return a marshalled object');
  };

  /**
   * WithAsyncValueProvider (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithAsyncValueProvider(IResourceBuilder<TestRedisResource> builder, Func<Task<String>> asyncValueProvider)
   */
  withAsyncValueProvider(asyncValueProvider: () => Promise<string>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(this._withAsyncValueProviderInternal(asyncValueProvider));
  }

   /**
   * WithQuadCallback
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithQuadCallback(IResourceBuilder<TestRedisResource> builder, Action<String, Int32, Boolean, Double> callback)
   * @param {(p0: string, p1: number, p2: boolean, p3: number) => void | Promise<void>} callback C# Type: Action<String, Int32, Boolean, Double>
   * @returns {TestRedisResourceBuilder} C# Type: IResourceBuilder<TestRedisResource>
   */
  /** @internal */
  async _withQuadCallbackInternal(callback: (p0: string, p1: number, p2: boolean, p3: number) => void | Promise<void>) : Promise<TestRedisResourceBuilder> {
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithQuadCallback', {builder: this._proxy, callback: registerCallback(callback)});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestRedisResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithQuadCallback did not return a marshalled object');
  };

  /**
   * WithQuadCallback (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithQuadCallback(IResourceBuilder<TestRedisResource> builder, Action<String, Int32, Boolean, Double> callback)
   */
  withQuadCallback(callback: (p0: string, p1: number, p2: boolean, p3: number) => void | Promise<void>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(this._withQuadCallbackInternal(callback));
  }

   /**
   * WithQuadTransform
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithQuadTransform(IResourceBuilder<TestRedisResource> builder, Func<String, Int32, Boolean, Double, String> transform)
   * @param {(p0: string, p1: number, p2: boolean, p3: number) => string | Promise<string>} transform C# Type: Func<String, Int32, Boolean, Double, String>
   * @returns {TestRedisResourceBuilder} C# Type: IResourceBuilder<TestRedisResource>
   */
  /** @internal */
  async _withQuadTransformInternal(transform: (p0: string, p1: number, p2: boolean, p3: number) => string | Promise<string>) : Promise<TestRedisResourceBuilder> {
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithQuadTransform', {builder: this._proxy, transform: registerCallback(transform)});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestRedisResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithQuadTransform did not return a marshalled object');
  };

  /**
   * WithQuadTransform (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithQuadTransform(IResourceBuilder<TestRedisResource> builder, Func<String, Int32, Boolean, Double, String> transform)
   */
  withQuadTransform(transform: (p0: string, p1: number, p2: boolean, p3: number) => string | Promise<string>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(this._withQuadTransformInternal(transform));
  }

   /**
   * WithCustomCallback
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithCustomCallback<TestRedisResource>(IResourceBuilder<T> builder, Action<TestCallbackContext> callback)
   * @param {(p0: TestCallbackContextProxy) => void | Promise<void>} callback C# Type: Action<TestCallbackContext>
   * @returns {TestRedisResourceBuilder} C# Type: IResourceBuilder<TestRedisResource>
   */
  /** @internal */
  async _withCustomCallbackInternal(callback: (p0: TestCallbackContextProxy) => void | Promise<void>) : Promise<TestRedisResourceBuilder> {
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithCustomCallback', {builder: this._proxy, callback: registerCallback((arg: DotNetProxy) => callback(new TestCallbackContextProxy(arg)))});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestRedisResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithCustomCallback did not return a marshalled object');
  };

  /**
   * WithCustomCallback (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithCustomCallback<TestRedisResource>(IResourceBuilder<T> builder, Action<TestCallbackContext> callback)
   */
  withCustomCallback(callback: (p0: TestCallbackContextProxy) => void | Promise<void>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(this._withCustomCallbackInternal(callback));
  }

   /**
   * WithOptionalString
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithOptionalString<TestRedisResource>(IResourceBuilder<T> builder, String value, Boolean enabled)
   * @param {string} value C# Type: String
   * @param {boolean} enabled C# Type: Boolean
   * @returns {TestRedisResourceBuilder} C# Type: IResourceBuilder<TestRedisResource>
   */
  /** @internal */
  async _withOptionalStringInternal(optionalArguments: WithOptionalStringArgs = new WithOptionalStringArgs()) : Promise<TestRedisResourceBuilder> {
    optionalArguments = Object.assign(new WithOptionalStringArgs(), optionalArguments);
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithOptionalString', {builder: this._proxy, value: optionalArguments?.value || null, enabled: optionalArguments?.enabled || null});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestRedisResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithOptionalString did not return a marshalled object');
  };

  /**
   * WithOptionalString (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithOptionalString<TestRedisResource>(IResourceBuilder<T> builder, String value, Boolean enabled)
   */
  withOptionalString(optionalArguments: WithOptionalStringArgs = new WithOptionalStringArgs()): TestRedisResourceBuilderPromise {
    optionalArguments = Object.assign(new WithOptionalStringArgs(), optionalArguments);
    return new TestRedisResourceBuilderPromise(this._withOptionalStringInternal(optionalArguments));
  }

   /**
   * WithMultipleDefaults
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithMultipleDefaults<TestRedisResource>(IResourceBuilder<T> builder, Int32 count, String prefix, Boolean useUpperCase, Double multiplier)
   * @param {number} count C# Type: Int32
   * @param {string} prefix C# Type: String
   * @param {boolean} useUpperCase C# Type: Boolean
   * @param {number} multiplier C# Type: Double
   * @returns {TestRedisResourceBuilder} C# Type: IResourceBuilder<TestRedisResource>
   */
  /** @internal */
  async _withMultipleDefaultsInternal(optionalArguments: WithMultipleDefaultsArgs = new WithMultipleDefaultsArgs()) : Promise<TestRedisResourceBuilder> {
    optionalArguments = Object.assign(new WithMultipleDefaultsArgs(), optionalArguments);
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithMultipleDefaults', {builder: this._proxy, count: optionalArguments?.count || null, prefix: optionalArguments?.prefix || null, useUpperCase: optionalArguments?.useUpperCase || null, multiplier: optionalArguments?.multiplier || null});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestRedisResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithMultipleDefaults did not return a marshalled object');
  };

  /**
   * WithMultipleDefaults (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithMultipleDefaults<TestRedisResource>(IResourceBuilder<T> builder, Int32 count, String prefix, Boolean useUpperCase, Double multiplier)
   */
  withMultipleDefaults(optionalArguments: WithMultipleDefaultsArgs = new WithMultipleDefaultsArgs()): TestRedisResourceBuilderPromise {
    optionalArguments = Object.assign(new WithMultipleDefaultsArgs(), optionalArguments);
    return new TestRedisResourceBuilderPromise(this._withMultipleDefaultsInternal(optionalArguments));
  }
}

/**
 * Thenable wrapper for TestRedisResourceBuilder that enables fluent chaining.
 * Usage: await builder.addX("name").withY().withZ();
 */
export class TestRedisResourceBuilderPromise implements PromiseLike<TestRedisResourceBuilder> {
  constructor(private _promise: Promise<TestRedisResourceBuilder>) {}

  then<TResult1 = TestRedisResourceBuilder, TResult2 = never>(
    onfulfilled?: ((value: TestRedisResourceBuilder) => TResult1 | PromiseLike<TResult1>) | null,
    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null
  ): PromiseLike<TResult1 | TResult2> {
    return this._promise.then(onfulfilled, onrejected);
  }

  /**
   * WithPersistence (fluent chaining)
   */
  withPersistence(mode?: TestPersistenceMode): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(
      this._promise.then(b => b._withPersistenceInternal(mode))
    );
  }

  /**
   * WithBuilderCallback (fluent chaining)
   */
  withBuilderCallback(configure?: (p0: TestRedisResourceBuilder) => void | Promise<void>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(
      this._promise.then(b => b._withBuilderCallbackInternal(configure))
    );
  }

  /**
   * AsConnectionString (fluent chaining)
   */
  asConnectionString(): IResourceWithConnectionStringBuilderPromise {
    return new IResourceWithConnectionStringBuilderPromise(
      this._promise.then(b => b._asConnectionStringInternal())
    );
  }

  /**
   * WithCircularCallback (fluent chaining)
   */
  withCircularCallback(configure: (p0: TestRedisResourceBuilder) => void | Promise<void>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(
      this._promise.then(b => b._withCircularCallbackInternal(configure))
    );
  }

  /**
   * WithNestedCallback (fluent chaining)
   */
  withNestedCallback(outerConfigure: (p0: (p0: TestRedisResourceBuilder) => void | Promise<void>) => void | Promise<void>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(
      this._promise.then(b => b._withNestedCallbackInternal(outerConfigure))
    );
  }

  /**
   * WithAsyncCallback (fluent chaining)
   */
  withAsyncCallback(asyncCallback: (p0: TestCallbackContextProxy) => Promise<void>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(
      this._promise.then(b => b._withAsyncCallbackInternal(asyncCallback))
    );
  }

  /**
   * WithAsyncCallbackWithResult (fluent chaining)
   */
  withAsyncCallbackWithResult(asyncCallback: (p0: TestCallbackContextProxy) => Promise<boolean>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(
      this._promise.then(b => b._withAsyncCallbackWithResultInternal(asyncCallback))
    );
  }

  /**
   * WithAsyncBuilderCallback (fluent chaining)
   */
  withAsyncBuilderCallback(asyncConfigure: (p0: TestRedisResourceBuilder) => Promise<void>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(
      this._promise.then(b => b._withAsyncBuilderCallbackInternal(asyncConfigure))
    );
  }

  /**
   * WithTags (fluent chaining)
   */
  withTags(tags: Array<string>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(
      this._promise.then(b => b._withTagsInternal(tags))
    );
  }

  /**
   * WithLabels (fluent chaining)
   */
  withLabels(labels: Array<string>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(
      this._promise.then(b => b._withLabelsInternal(labels))
    );
  }

  /**
   * WithMetadata (fluent chaining)
   */
  withMetadata(metadata: Map<string, string>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(
      this._promise.then(b => b._withMetadataInternal(metadata))
    );
  }

  /**
   * WithItems (fluent chaining)
   */
  withItems(items: Array<string>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(
      this._promise.then(b => b._withItemsInternal(items))
    );
  }

  /**
   * WithTimeout (fluent chaining)
   */
  withTimeout(timeoutSeconds?: number | null): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(
      this._promise.then(b => b._withTimeoutInternal(timeoutSeconds))
    );
  }

  /**
   * WithLimits (fluent chaining)
   */
  withLimits(optionalArguments?: WithLimitsArgs): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(
      this._promise.then(b => b._withLimitsInternal(optionalArguments))
    );
  }

  /**
   * WithExpiry (fluent chaining)
   */
  withExpiry(expiry: number): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(
      this._promise.then(b => b._withExpiryInternal(expiry))
    );
  }

  /**
   * WithOptionalExpiry (fluent chaining)
   */
  withOptionalExpiry(expiry?: number | null): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(
      this._promise.then(b => b._withOptionalExpiryInternal(expiry))
    );
  }

  /**
   * WithTransform (fluent chaining)
   */
  withTransform(transform: (p0: string, p1: number) => string | Promise<string>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(
      this._promise.then(b => b._withTransformInternal(transform))
    );
  }

  /**
   * WithMultiParamCallback (fluent chaining)
   */
  withMultiParamCallback(callback: (p0: string, p1: number, p2: boolean) => void | Promise<void>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(
      this._promise.then(b => b._withMultiParamCallbackInternal(callback))
    );
  }

  /**
   * WithSetting (fluent chaining)
   */
  withSetting(setting: any): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(
      this._promise.then(b => b._withSettingInternal(setting))
    );
  }

  /**
   * WithEndpointMapping (fluent chaining)
   */
  withEndpointMapping(endpoint: any): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(
      this._promise.then(b => b._withEndpointMappingInternal(endpoint))
    );
  }

  /**
   * WithProxyUrl (fluent chaining)
   */
  withProxyUrl(proxyUrl: string): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(
      this._promise.then(b => b._withProxyUrlInternal(proxyUrl))
    );
  }

  /**
   * WithCallbackContexts (fluent chaining)
   */
  withCallbackContexts(contexts: Array<TestCallbackContextProxy>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(
      this._promise.then(b => b._withCallbackContextsInternal(contexts))
    );
  }

  /**
   * WithSimpleCallback (fluent chaining)
   */
  withSimpleCallback(callback: () => void | Promise<void>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(
      this._promise.then(b => b._withSimpleCallbackInternal(callback))
    );
  }

  /**
   * WithValueProvider (fluent chaining)
   */
  withValueProvider(valueProvider: () => string | Promise<string>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(
      this._promise.then(b => b._withValueProviderInternal(valueProvider))
    );
  }

  /**
   * WithAsyncValueProvider (fluent chaining)
   */
  withAsyncValueProvider(asyncValueProvider: () => Promise<string>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(
      this._promise.then(b => b._withAsyncValueProviderInternal(asyncValueProvider))
    );
  }

  /**
   * WithQuadCallback (fluent chaining)
   */
  withQuadCallback(callback: (p0: string, p1: number, p2: boolean, p3: number) => void | Promise<void>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(
      this._promise.then(b => b._withQuadCallbackInternal(callback))
    );
  }

  /**
   * WithQuadTransform (fluent chaining)
   */
  withQuadTransform(transform: (p0: string, p1: number, p2: boolean, p3: number) => string | Promise<string>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(
      this._promise.then(b => b._withQuadTransformInternal(transform))
    );
  }

  /**
   * WithCustomCallback (fluent chaining)
   */
  withCustomCallback(callback: (p0: TestCallbackContextProxy) => void | Promise<void>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(
      this._promise.then(b => b._withCustomCallbackInternal(callback))
    );
  }

  /**
   * WithOptionalString (fluent chaining)
   */
  withOptionalString(optionalArguments?: WithOptionalStringArgs): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(
      this._promise.then(b => b._withOptionalStringInternal(optionalArguments))
    );
  }

  /**
   * WithMultipleDefaults (fluent chaining)
   */
  withMultipleDefaults(optionalArguments?: WithMultipleDefaultsArgs): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(
      this._promise.then(b => b._withMultipleDefaultsInternal(optionalArguments))
    );
  }
}

export class TestDatabaseResourceBuilder {
  constructor(protected _proxy: DotNetProxy) {}

  /** Gets the underlying proxy */
  get proxy(): DotNetProxy { return this._proxy; }

   /**
   * WithCustomCallback
   * @remarks C# Definition: IResourceBuilder<TestDatabaseResource> WithCustomCallback<TestDatabaseResource>(IResourceBuilder<T> builder, Action<TestCallbackContext> callback)
   * @param {(p0: TestCallbackContextProxy) => void | Promise<void>} callback C# Type: Action<TestCallbackContext>
   * @returns {TestDatabaseResourceBuilder} C# Type: IResourceBuilder<TestDatabaseResource>
   */
  /** @internal */
  async _withCustomCallbackInternal(callback: (p0: TestCallbackContextProxy) => void | Promise<void>) : Promise<TestDatabaseResourceBuilder> {
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithCustomCallback', {builder: this._proxy, callback: registerCallback((arg: DotNetProxy) => callback(new TestCallbackContextProxy(arg)))});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestDatabaseResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithCustomCallback did not return a marshalled object');
  };

  /**
   * WithCustomCallback (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestDatabaseResource> WithCustomCallback<TestDatabaseResource>(IResourceBuilder<T> builder, Action<TestCallbackContext> callback)
   */
  withCustomCallback(callback: (p0: TestCallbackContextProxy) => void | Promise<void>): TestDatabaseResourceBuilderPromise {
    return new TestDatabaseResourceBuilderPromise(this._withCustomCallbackInternal(callback));
  }

   /**
   * WithOptionalString
   * @remarks C# Definition: IResourceBuilder<TestDatabaseResource> WithOptionalString<TestDatabaseResource>(IResourceBuilder<T> builder, String value, Boolean enabled)
   * @param {string} value C# Type: String
   * @param {boolean} enabled C# Type: Boolean
   * @returns {TestDatabaseResourceBuilder} C# Type: IResourceBuilder<TestDatabaseResource>
   */
  /** @internal */
  async _withOptionalStringInternal(optionalArguments: WithOptionalStringArgs1 = new WithOptionalStringArgs1()) : Promise<TestDatabaseResourceBuilder> {
    optionalArguments = Object.assign(new WithOptionalStringArgs1(), optionalArguments);
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithOptionalString', {builder: this._proxy, value: optionalArguments?.value || null, enabled: optionalArguments?.enabled || null});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestDatabaseResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithOptionalString did not return a marshalled object');
  };

  /**
   * WithOptionalString (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestDatabaseResource> WithOptionalString<TestDatabaseResource>(IResourceBuilder<T> builder, String value, Boolean enabled)
   */
  withOptionalString(optionalArguments: WithOptionalStringArgs1 = new WithOptionalStringArgs1()): TestDatabaseResourceBuilderPromise {
    optionalArguments = Object.assign(new WithOptionalStringArgs1(), optionalArguments);
    return new TestDatabaseResourceBuilderPromise(this._withOptionalStringInternal(optionalArguments));
  }

   /**
   * WithMultipleDefaults
   * @remarks C# Definition: IResourceBuilder<TestDatabaseResource> WithMultipleDefaults<TestDatabaseResource>(IResourceBuilder<T> builder, Int32 count, String prefix, Boolean useUpperCase, Double multiplier)
   * @param {number} count C# Type: Int32
   * @param {string} prefix C# Type: String
   * @param {boolean} useUpperCase C# Type: Boolean
   * @param {number} multiplier C# Type: Double
   * @returns {TestDatabaseResourceBuilder} C# Type: IResourceBuilder<TestDatabaseResource>
   */
  /** @internal */
  async _withMultipleDefaultsInternal(optionalArguments: WithMultipleDefaultsArgs1 = new WithMultipleDefaultsArgs1()) : Promise<TestDatabaseResourceBuilder> {
    optionalArguments = Object.assign(new WithMultipleDefaultsArgs1(), optionalArguments);
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithMultipleDefaults', {builder: this._proxy, count: optionalArguments?.count || null, prefix: optionalArguments?.prefix || null, useUpperCase: optionalArguments?.useUpperCase || null, multiplier: optionalArguments?.multiplier || null});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestDatabaseResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithMultipleDefaults did not return a marshalled object');
  };

  /**
   * WithMultipleDefaults (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestDatabaseResource> WithMultipleDefaults<TestDatabaseResource>(IResourceBuilder<T> builder, Int32 count, String prefix, Boolean useUpperCase, Double multiplier)
   */
  withMultipleDefaults(optionalArguments: WithMultipleDefaultsArgs1 = new WithMultipleDefaultsArgs1()): TestDatabaseResourceBuilderPromise {
    optionalArguments = Object.assign(new WithMultipleDefaultsArgs1(), optionalArguments);
    return new TestDatabaseResourceBuilderPromise(this._withMultipleDefaultsInternal(optionalArguments));
  }
}

/**
 * Thenable wrapper for TestDatabaseResourceBuilder that enables fluent chaining.
 * Usage: await builder.addX("name").withY().withZ();
 */
export class TestDatabaseResourceBuilderPromise implements PromiseLike<TestDatabaseResourceBuilder> {
  constructor(private _promise: Promise<TestDatabaseResourceBuilder>) {}

  then<TResult1 = TestDatabaseResourceBuilder, TResult2 = never>(
    onfulfilled?: ((value: TestDatabaseResourceBuilder) => TResult1 | PromiseLike<TResult1>) | null,
    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null
  ): PromiseLike<TResult1 | TResult2> {
    return this._promise.then(onfulfilled, onrejected);
  }

  /**
   * WithCustomCallback (fluent chaining)
   */
  withCustomCallback(callback: (p0: TestCallbackContextProxy) => void | Promise<void>): TestDatabaseResourceBuilderPromise {
    return new TestDatabaseResourceBuilderPromise(
      this._promise.then(b => b._withCustomCallbackInternal(callback))
    );
  }

  /**
   * WithOptionalString (fluent chaining)
   */
  withOptionalString(optionalArguments?: WithOptionalStringArgs1): TestDatabaseResourceBuilderPromise {
    return new TestDatabaseResourceBuilderPromise(
      this._promise.then(b => b._withOptionalStringInternal(optionalArguments))
    );
  }

  /**
   * WithMultipleDefaults (fluent chaining)
   */
  withMultipleDefaults(optionalArguments?: WithMultipleDefaultsArgs1): TestDatabaseResourceBuilderPromise {
    return new TestDatabaseResourceBuilderPromise(
      this._promise.then(b => b._withMultipleDefaultsInternal(optionalArguments))
    );
  }
}

export class IResourceWithConnectionStringBuilder {
  constructor(protected _proxy: DotNetProxy) {}

  /** Gets the underlying proxy */
  get proxy(): DotNetProxy { return this._proxy; }
}

/**
 * Thenable wrapper for IResourceWithConnectionStringBuilder that enables fluent chaining.
 * Usage: await builder.addX("name").withY().withZ();
 */
export class IResourceWithConnectionStringBuilderPromise implements PromiseLike<IResourceWithConnectionStringBuilder> {
  constructor(private _promise: Promise<IResourceWithConnectionStringBuilder>) {}

  then<TResult1 = IResourceWithConnectionStringBuilder, TResult2 = never>(
    onfulfilled?: ((value: IResourceWithConnectionStringBuilder) => TResult1 | PromiseLike<TResult1>) | null,
    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null
  ): PromiseLike<TResult1 | TResult2> {
    return this._promise.then(onfulfilled, onrejected);
  }
}

export enum TestPersistenceMode {
  None = "None", Volume = "Volume", Bind = "Bind"
}

/**
 * Typed proxy wrapper for CancellationToken
 * Provides typed access to .NET object properties via JSON-RPC
 */
export class CancellationTokenProxy {
    constructor(private _proxy: DotNetProxy) {}

    /** Get the underlying proxy for advanced operations */
    get proxy(): DotNetProxy { return this._proxy; }

    /** The .NET type name */
    get $type(): string { return this._proxy.$type; }

    /** The object identifier for use in method calls */
    get $id(): string { return this._proxy.$id; }

    /**
     * Gets the static None property
     * @returns Promise<CancellationTokenProxy>
     */
    static async getNone(client: RemoteAppHostClient): Promise<CancellationTokenProxy> {
        const result = await client.getStaticProperty("System.Private.CoreLib", "System.Threading.CancellationToken", "None");
        return new CancellationTokenProxy(wrapIfProxy(result) as DotNetProxy);
    }

    /**
     * Gets the IsCancellationRequested property
     * @returns Promise<boolean>
     */
    async getIsCancellationRequested(): Promise<boolean> {
        const result = await this._proxy.getProperty("IsCancellationRequested");
        return result as boolean;
    }

    /**
     * Gets the CanBeCanceled property
     * @returns Promise<boolean>
     */
    async getCanBeCanceled(): Promise<boolean> {
        const result = await this._proxy.getProperty("CanBeCanceled");
        return result as boolean;
    }

    /**
     * Gets the WaitHandle property
     * @returns Promise<any>
     */
    async getWaitHandle(): Promise<any> {
        const result = await this._proxy.getProperty("WaitHandle");
        return result as any;
    }

    /**
     * Gets a property value from the .NET object (generic fallback)
     * @param propertyName The property name
     */
    async getProperty<T = unknown>(propertyName: string): Promise<T> {
        const result = await this._proxy.getProperty(propertyName);
        return result as T;
    }

    /**
     * Sets a property value on the .NET object (generic fallback)
     * @param propertyName The property name
     * @param value The value to set
     */
    async setProperty(propertyName: string, value: unknown): Promise<void> {
        await this._proxy.setProperty(propertyName, value);
    }

    /**
     * Invokes a method on the .NET object (generic fallback)
     * @param methodName The method name
     * @param args The method arguments
     */
    async invokeMethod<T = unknown>(methodName: string, args?: Record<string, unknown>): Promise<T> {
        const result = await this._proxy.invokeMethod(methodName, args);
        return result as T;
    }
}

/**
 * Typed proxy wrapper for PipelineStepContext
 * Provides typed access to .NET object properties via JSON-RPC
 */
export class PipelineStepContextProxy {
    constructor(private _proxy: DotNetProxy) {}

    /** Get the underlying proxy for advanced operations */
    get proxy(): DotNetProxy { return this._proxy; }

    /** The .NET type name */
    get $type(): string { return this._proxy.$type; }

    /** The object identifier for use in method calls */
    get $id(): string { return this._proxy.$id; }

    /**
     * Gets the PipelineContext property
     * @returns Promise<any>
     */
    async getPipelineContext(): Promise<any> {
        const result = await this._proxy.getProperty("PipelineContext");
        return result as any;
    }

    /**
     * Sets the PipelineContext property
     */
    async setPipelineContext(value: any): Promise<void> {
        await this._proxy.setProperty("PipelineContext", value);
    }

    /**
     * Gets the ReportingStep property
     * @returns Promise<any>
     */
    async getReportingStep(): Promise<any> {
        const result = await this._proxy.getProperty("ReportingStep");
        return result as any;
    }

    /**
     * Sets the ReportingStep property
     */
    async setReportingStep(value: any): Promise<void> {
        await this._proxy.setProperty("ReportingStep", value);
    }

    /**
     * Gets the Model property
     * @returns Promise<any>
     */
    async getModel(): Promise<any> {
        const result = await this._proxy.getProperty("Model");
        return result as any;
    }

    /**
     * Gets the ExecutionContext property
     * @returns Promise<DistributedApplicationExecutionContextProxy>
     */
    async getExecutionContext(): Promise<DistributedApplicationExecutionContextProxy> {
        const result = await this._proxy.getProperty("ExecutionContext");
        return result as DistributedApplicationExecutionContextProxy;
    }

    /**
     * Gets the Services property
     * @returns Promise<ServiceProviderProxy>
     */
    async getServices(): Promise<ServiceProviderProxy> {
        const result = await this._proxy.getProperty("Services");
        return result as ServiceProviderProxy;
    }

    /**
     * Gets the Logger property
     * @returns Promise<any>
     */
    async getLogger(): Promise<any> {
        const result = await this._proxy.getProperty("Logger");
        return result as any;
    }

    /**
     * Gets the CancellationToken property
     * @returns Promise<CancellationTokenProxy>
     */
    async getCancellationToken(): Promise<CancellationTokenProxy> {
        const result = await this._proxy.getProperty("CancellationToken");
        return new CancellationTokenProxy(result as DotNetProxy);
    }

    /**
     * Gets a property value from the .NET object (generic fallback)
     * @param propertyName The property name
     */
    async getProperty<T = unknown>(propertyName: string): Promise<T> {
        const result = await this._proxy.getProperty(propertyName);
        return result as T;
    }

    /**
     * Sets a property value on the .NET object (generic fallback)
     * @param propertyName The property name
     * @param value The value to set
     */
    async setProperty(propertyName: string, value: unknown): Promise<void> {
        await this._proxy.setProperty(propertyName, value);
    }

    /**
     * Invokes a method on the .NET object (generic fallback)
     * @param methodName The method name
     * @param args The method arguments
     */
    async invokeMethod<T = unknown>(methodName: string, args?: Record<string, unknown>): Promise<T> {
        const result = await this._proxy.invokeMethod(methodName, args);
        return result as T;
    }
}

/**
 * Typed proxy wrapper for PipelineConfigurationContext
 * Provides typed access to .NET object properties via JSON-RPC
 */
export class PipelineConfigurationContextProxy {
    constructor(private _proxy: DotNetProxy) {}

    /** Get the underlying proxy for advanced operations */
    get proxy(): DotNetProxy { return this._proxy; }

    /** The .NET type name */
    get $type(): string { return this._proxy.$type; }

    /** The object identifier for use in method calls */
    get $id(): string { return this._proxy.$id; }

    /**
     * Gets the Services property
     * @returns Promise<ServiceProviderProxy>
     */
    async getServices(): Promise<ServiceProviderProxy> {
        const result = await this._proxy.getProperty("Services");
        return result as ServiceProviderProxy;
    }

    /**
     * Sets the Services property
     */
    async setServices(value: ServiceProviderProxy): Promise<void> {
        await this._proxy.setProperty("Services", value);
    }

    /**
     * Gets the Steps property
     * @returns Promise<Array<any>>
     */
    async getSteps(): Promise<Array<any>> {
        const result = await this._proxy.getProperty("Steps");
        return result as Array<any>;
    }

    /**
     * Sets the Steps property
     */
    async setSteps(value: Array<any>): Promise<void> {
        await this._proxy.setProperty("Steps", value);
    }

    /**
     * Gets the Model property
     * @returns Promise<any>
     */
    async getModel(): Promise<any> {
        const result = await this._proxy.getProperty("Model");
        return result as any;
    }

    /**
     * Sets the Model property
     */
    async setModel(value: any): Promise<void> {
        await this._proxy.setProperty("Model", value);
    }

    /**
     * Gets a property value from the .NET object (generic fallback)
     * @param propertyName The property name
     */
    async getProperty<T = unknown>(propertyName: string): Promise<T> {
        const result = await this._proxy.getProperty(propertyName);
        return result as T;
    }

    /**
     * Sets a property value on the .NET object (generic fallback)
     * @param propertyName The property name
     * @param value The value to set
     */
    async setProperty(propertyName: string, value: unknown): Promise<void> {
        await this._proxy.setProperty(propertyName, value);
    }

    /**
     * Invokes a method on the .NET object (generic fallback)
     * @param methodName The method name
     * @param args The method arguments
     */
    async invokeMethod<T = unknown>(methodName: string, args?: Record<string, unknown>): Promise<T> {
        const result = await this._proxy.invokeMethod(methodName, args);
        return result as T;
    }
}

/**
 * Typed proxy wrapper for ResourceEvent
 * Provides typed access to .NET object properties via JSON-RPC
 */
export class ResourceEventProxy {
    constructor(private _proxy: DotNetProxy) {}

    /** Get the underlying proxy for advanced operations */
    get proxy(): DotNetProxy { return this._proxy; }

    /** The .NET type name */
    get $type(): string { return this._proxy.$type; }

    /** The object identifier for use in method calls */
    get $id(): string { return this._proxy.$id; }

    /**
     * Gets the Resource property
     * @returns Promise<any>
     */
    async getResource(): Promise<any> {
        const result = await this._proxy.getProperty("Resource");
        return result as any;
    }

    /**
     * Gets the ResourceId property
     * @returns Promise<string>
     */
    async getResourceId(): Promise<string> {
        const result = await this._proxy.getProperty("ResourceId");
        return result as string;
    }

    /**
     * Gets the Snapshot property
     * @returns Promise<CustomResourceSnapshotProxy>
     */
    async getSnapshot(): Promise<CustomResourceSnapshotProxy> {
        const result = await this._proxy.getProperty("Snapshot");
        return new CustomResourceSnapshotProxy(result as DotNetProxy);
    }

    /**
     * Gets a property value from the .NET object (generic fallback)
     * @param propertyName The property name
     */
    async getProperty<T = unknown>(propertyName: string): Promise<T> {
        const result = await this._proxy.getProperty(propertyName);
        return result as T;
    }

    /**
     * Sets a property value on the .NET object (generic fallback)
     * @param propertyName The property name
     * @param value The value to set
     */
    async setProperty(propertyName: string, value: unknown): Promise<void> {
        await this._proxy.setProperty(propertyName, value);
    }

    /**
     * Invokes a method on the .NET object (generic fallback)
     * @param methodName The method name
     * @param args The method arguments
     */
    async invokeMethod<T = unknown>(methodName: string, args?: Record<string, unknown>): Promise<T> {
        const result = await this._proxy.invokeMethod(methodName, args);
        return result as T;
    }
}

/**
 * Typed proxy wrapper for CustomResourceSnapshot
 * Provides typed access to .NET object properties via JSON-RPC
 */
export class CustomResourceSnapshotProxy {
    constructor(private _proxy: DotNetProxy) {}

    /** Get the underlying proxy for advanced operations */
    get proxy(): DotNetProxy { return this._proxy; }

    /** The .NET type name */
    get $type(): string { return this._proxy.$type; }

    /** The object identifier for use in method calls */
    get $id(): string { return this._proxy.$id; }

    /**
     * Gets the ResourceType property
     * @returns Promise<string>
     */
    async getResourceType(): Promise<string> {
        const result = await this._proxy.getProperty("ResourceType");
        return result as string;
    }

    /**
     * Sets the ResourceType property
     */
    async setResourceType(value: string): Promise<void> {
        await this._proxy.setProperty("ResourceType", value);
    }

    /**
     * Gets the Properties property
     * @returns Promise<any>
     */
    async getProperties(): Promise<any> {
        const result = await this._proxy.getProperty("Properties");
        return result as any;
    }

    /**
     * Sets the Properties property
     */
    async setProperties(value: any): Promise<void> {
        await this._proxy.setProperty("Properties", value);
    }

    /**
     * Gets the CreationTimeStamp property
     * @returns Promise<Date | null>
     */
    async getCreationTimeStamp(): Promise<Date | null> {
        const result = await this._proxy.getProperty("CreationTimeStamp");
        return result as Date | null;
    }

    /**
     * Sets the CreationTimeStamp property
     */
    async setCreationTimeStamp(value: Date | null): Promise<void> {
        await this._proxy.setProperty("CreationTimeStamp", value);
    }

    /**
     * Gets the StartTimeStamp property
     * @returns Promise<Date | null>
     */
    async getStartTimeStamp(): Promise<Date | null> {
        const result = await this._proxy.getProperty("StartTimeStamp");
        return result as Date | null;
    }

    /**
     * Sets the StartTimeStamp property
     */
    async setStartTimeStamp(value: Date | null): Promise<void> {
        await this._proxy.setProperty("StartTimeStamp", value);
    }

    /**
     * Gets the StopTimeStamp property
     * @returns Promise<Date | null>
     */
    async getStopTimeStamp(): Promise<Date | null> {
        const result = await this._proxy.getProperty("StopTimeStamp");
        return result as Date | null;
    }

    /**
     * Sets the StopTimeStamp property
     */
    async setStopTimeStamp(value: Date | null): Promise<void> {
        await this._proxy.setProperty("StopTimeStamp", value);
    }

    /**
     * Gets the State property
     * @returns Promise<any>
     */
    async getState(): Promise<any> {
        const result = await this._proxy.getProperty("State");
        return result as any;
    }

    /**
     * Sets the State property
     */
    async setState(value: any): Promise<void> {
        await this._proxy.setProperty("State", value);
    }

    /**
     * Gets the ExitCode property
     * @returns Promise<number | null>
     */
    async getExitCode(): Promise<number | null> {
        const result = await this._proxy.getProperty("ExitCode");
        return result as number | null;
    }

    /**
     * Sets the ExitCode property
     */
    async setExitCode(value: number | null): Promise<void> {
        await this._proxy.setProperty("ExitCode", value);
    }

    /**
     * Gets the HealthStatus property
     * @returns Promise<HealthStatus | null>
     */
    async getHealthStatus(): Promise<HealthStatus | null> {
        const result = await this._proxy.getProperty("HealthStatus");
        return result as HealthStatus | null;
    }

    /**
     * Gets the HealthReports property
     * @returns Promise<any>
     */
    async getHealthReports(): Promise<any> {
        const result = await this._proxy.getProperty("HealthReports");
        return result as any;
    }

    /**
     * Gets the EnvironmentVariables property
     * @returns Promise<any>
     */
    async getEnvironmentVariables(): Promise<any> {
        const result = await this._proxy.getProperty("EnvironmentVariables");
        return result as any;
    }

    /**
     * Sets the EnvironmentVariables property
     */
    async setEnvironmentVariables(value: any): Promise<void> {
        await this._proxy.setProperty("EnvironmentVariables", value);
    }

    /**
     * Gets the Urls property
     * @returns Promise<any>
     */
    async getUrls(): Promise<any> {
        const result = await this._proxy.getProperty("Urls");
        return result as any;
    }

    /**
     * Sets the Urls property
     */
    async setUrls(value: any): Promise<void> {
        await this._proxy.setProperty("Urls", value);
    }

    /**
     * Gets the Volumes property
     * @returns Promise<any>
     */
    async getVolumes(): Promise<any> {
        const result = await this._proxy.getProperty("Volumes");
        return result as any;
    }

    /**
     * Sets the Volumes property
     */
    async setVolumes(value: any): Promise<void> {
        await this._proxy.setProperty("Volumes", value);
    }

    /**
     * Gets the Commands property
     * @returns Promise<any>
     */
    async getCommands(): Promise<any> {
        const result = await this._proxy.getProperty("Commands");
        return result as any;
    }

    /**
     * Sets the Commands property
     */
    async setCommands(value: any): Promise<void> {
        await this._proxy.setProperty("Commands", value);
    }

    /**
     * Gets the Relationships property
     * @returns Promise<any>
     */
    async getRelationships(): Promise<any> {
        const result = await this._proxy.getProperty("Relationships");
        return result as any;
    }

    /**
     * Sets the Relationships property
     */
    async setRelationships(value: any): Promise<void> {
        await this._proxy.setProperty("Relationships", value);
    }

    /**
     * Gets the IsHidden property
     * @returns Promise<boolean>
     */
    async getIsHidden(): Promise<boolean> {
        const result = await this._proxy.getProperty("IsHidden");
        return result as boolean;
    }

    /**
     * Sets the IsHidden property
     */
    async setIsHidden(value: boolean): Promise<void> {
        await this._proxy.setProperty("IsHidden", value);
    }

    /**
     * Gets the IconName property
     * @returns Promise<string>
     */
    async getIconName(): Promise<string> {
        const result = await this._proxy.getProperty("IconName");
        return result as string;
    }

    /**
     * Sets the IconName property
     */
    async setIconName(value: string): Promise<void> {
        await this._proxy.setProperty("IconName", value);
    }

    /**
     * Gets the IconVariant property
     * @returns Promise<IconVariant | null>
     */
    async getIconVariant(): Promise<IconVariant | null> {
        const result = await this._proxy.getProperty("IconVariant");
        return result as IconVariant | null;
    }

    /**
     * Sets the IconVariant property
     */
    async setIconVariant(value: IconVariant | null): Promise<void> {
        await this._proxy.setProperty("IconVariant", value);
    }

    /**
     * Gets a property value from the .NET object (generic fallback)
     * @param propertyName The property name
     */
    async getProperty<T = unknown>(propertyName: string): Promise<T> {
        const result = await this._proxy.getProperty(propertyName);
        return result as T;
    }

    /**
     * Sets a property value on the .NET object (generic fallback)
     * @param propertyName The property name
     * @param value The value to set
     */
    async setProperty(propertyName: string, value: unknown): Promise<void> {
        await this._proxy.setProperty(propertyName, value);
    }

    /**
     * Invokes a method on the .NET object (generic fallback)
     * @param methodName The method name
     * @param args The method arguments
     */
    async invokeMethod<T = unknown>(methodName: string, args?: Record<string, unknown>): Promise<T> {
        const result = await this._proxy.invokeMethod(methodName, args);
        return result as T;
    }
}

/**
 * Typed proxy wrapper for TestCallbackContext
 * Provides typed access to .NET object properties via JSON-RPC
 */
export class TestCallbackContextProxy {
    constructor(private _proxy: DotNetProxy) {}

    /** Get the underlying proxy for advanced operations */
    get proxy(): DotNetProxy { return this._proxy; }

    /** The .NET type name */
    get $type(): string { return this._proxy.$type; }

    /** The object identifier for use in method calls */
    get $id(): string { return this._proxy.$id; }

    /**
     * Gets the Name property
     * @returns Promise<string>
     */
    async getName(): Promise<string> {
        const result = await this._proxy.getProperty("Name");
        return result as string;
    }

    /**
     * Sets the Name property
     */
    async setName(value: string): Promise<void> {
        await this._proxy.setProperty("Name", value);
    }

    /**
     * Gets the Value property
     * @returns Promise<number>
     */
    async getValue(): Promise<number> {
        const result = await this._proxy.getProperty("Value");
        return result as number;
    }

    /**
     * Sets the Value property
     */
    async setValue(value: number): Promise<void> {
        await this._proxy.setProperty("Value", value);
    }

    /**
     * Gets the CancellationToken property
     * @returns Promise<CancellationTokenProxy>
     */
    async getCancellationToken(): Promise<CancellationTokenProxy> {
        const result = await this._proxy.getProperty("CancellationToken");
        return new CancellationTokenProxy(result as DotNetProxy);
    }

    /**
     * Sets the CancellationToken property
     */
    async setCancellationToken(value: CancellationTokenProxy): Promise<void> {
        await this._proxy.setProperty("CancellationToken", value);
    }

    /**
     * Gets a property value from the .NET object (generic fallback)
     * @param propertyName The property name
     */
    async getProperty<T = unknown>(propertyName: string): Promise<T> {
        const result = await this._proxy.getProperty(propertyName);
        return result as T;
    }

    /**
     * Sets a property value on the .NET object (generic fallback)
     * @param propertyName The property name
     * @param value The value to set
     */
    async setProperty(propertyName: string, value: unknown): Promise<void> {
        await this._proxy.setProperty(propertyName, value);
    }

    /**
     * Invokes a method on the .NET object (generic fallback)
     * @param methodName The method name
     * @param args The method arguments
     */
    async invokeMethod<T = unknown>(methodName: string, args?: Record<string, unknown>): Promise<T> {
        const result = await this._proxy.invokeMethod(methodName, args);
        return result as T;
    }
}
export class WithLimitsArgs {
      public maxConnections?: number | null;
      public memoryLimitMb?: number | null;
      public enableLogging?: boolean | null;

    constructor(args: Partial<WithLimitsArgs> = {}) {
      Object.assign(this, args);
    }
}
export class WithOptionalStringArgs {
      public value?: string;
      public enabled?: boolean;

    constructor(args: Partial<WithOptionalStringArgs> = {}) {
      this.enabled  = true;
      Object.assign(this, args);
    }
}
export class WithMultipleDefaultsArgs {
      public count?: number;
      public prefix?: string;
      public useUpperCase?: boolean;
      public multiplier?: number;

    constructor(args: Partial<WithMultipleDefaultsArgs> = {}) {
      this.count  = 10;
      this.prefix  = "item";
      this.useUpperCase  = false;
      this.multiplier  = 1.5;
      Object.assign(this, args);
    }
}
export class WithOptionalStringArgs1 {
      public value?: string;
      public enabled?: boolean;

    constructor(args: Partial<WithOptionalStringArgs1> = {}) {
      this.enabled  = true;
      Object.assign(this, args);
    }
}
export class WithMultipleDefaultsArgs1 {
      public count?: number;
      public prefix?: string;
      public useUpperCase?: boolean;
      public multiplier?: number;

    constructor(args: Partial<WithMultipleDefaultsArgs1> = {}) {
      this.count  = 10;
      this.prefix  = "item";
      this.useUpperCase  = false;
      this.multiplier  = 1.5;
      Object.assign(this, args);
    }
}
,
  RemoteAppHostClient.ts:
// RemoteAppHostClient.ts - Connects to the GenericAppHost via socket/named pipe
import * as net from 'net';
import * as rpc from 'vscode-jsonrpc/node.js';
import {
    CallbackFunction,
    MarshalledObject,
    MarshalledHandle,
    AtsError,
    isAtsError,
    isMarshalledHandle
} from './types.js';

// Callback registry - maps callback IDs to functions
const callbackRegistry = new Map<string, CallbackFunction>();
let callbackIdCounter = 0;

// Global reference to the client for proxy objects
let globalClient: RemoteAppHostClient | null = null;

/**
 * Register a callback function that can be invoked from the .NET side.
 * Returns a callback ID that should be passed to methods accepting callbacks.
 *
 * Supports both single-argument and multi-argument callbacks:
 * - Single arg: `(context: SomeType) => void`
 * - Multi arg: `(p0: string, p1: number) => boolean`
 *
 * .NET passes arguments as an object `{ p0: value0, p1: value1, ... }` which
 * this function automatically unpacks for multi-parameter callbacks.
 */
export function registerCallback<TResult = void>(
    callback: (...args: any[]) => TResult | Promise<TResult>
): string {
    const callbackId = `callback_${++callbackIdCounter}_${Date.now()}`;

    // Wrap the callback to handle .NET's argument format
    const wrapper: CallbackFunction = async (args: unknown) => {
        // .NET sends args as object { p0, p1, ... } - extract to array for multi-param callbacks
        if (args && typeof args === 'object' && !Array.isArray(args)) {
            const argObj = args as Record<string, unknown>;
            const argArray: unknown[] = [];

            // Check for positional parameters (p0, p1, p2, ...)
            for (let i = 0; ; i++) {
                const key = `p${i}`;
                if (key in argObj) {
                    argArray.push(wrapIfProxy(argObj[key]));
                } else {
                    break;
                }
            }

            if (argArray.length > 0) {
                // Multi-parameter callback - spread the args
                return await callback(...argArray);
            }

            // Single complex object parameter - wrap proxies and pass as-is
            return await callback(wrapIfProxy(args));
        }

        // Null/undefined or primitive - pass as single arg
        return await callback(wrapIfProxy(args));
    };

    callbackRegistry.set(callbackId, wrapper);
    return callbackId;
}

/**
 * Unregister a callback by its ID.
 */
export function unregisterCallback(callbackId: string): boolean {
    return callbackRegistry.delete(callbackId);
}

/**
 * Get the number of registered callbacks.
 */
export function getCallbackCount(): number {
    return callbackRegistry.size;
}

/**
 * A proxy object that represents a .NET object.
 * Allows calling methods and accessing properties on the remote object.
 */
export class DotNetProxy {
    private readonly _id: string;
    private readonly _type: string;
    private readonly _data: Record<string, unknown>;

    constructor(marshalled: MarshalledObject) {
        this._id = marshalled.$id;
        this._type = marshalled.$type;
        this._data = { ...marshalled };
    }

    /** The object ID in the .NET object registry */
    get $id(): string {
        return this._id;
    }

    /** The .NET type name */
    get $type(): string {
        return this._type;
    }

    /** Get a cached property value (may be stale) */
    getCachedValue(propertyName: string): unknown {
        return this._data[propertyName];
    }

    /** Serialize for JSON-RPC transport - includes $id so .NET can resolve the reference */
    toJSON() {
        return {
            $id: this._id,
            $type: this._type
        };
    }

    /** Invoke a method on the .NET object */
    async invokeMethod(methodName: string, args?: Record<string, unknown>): Promise<unknown> {
        if (!globalClient) {
            throw new Error('No connection to .NET host');
        }
        const result = await globalClient.invokeMethod(this._id, methodName, args);
        return wrapIfProxy(result);
    }

    /** Get a property value from the .NET object (fetches fresh value) */
    async getProperty(propertyName: string): Promise<unknown> {
        if (!globalClient) {
            throw new Error('No connection to .NET host');
        }
        const result = await globalClient.getProperty(this._id, propertyName);
        return wrapIfProxy(result);
    }

    /** Set a property value on the .NET object */
    async setProperty(propertyName: string, value: unknown): Promise<void> {
        if (!globalClient) {
            throw new Error('No connection to .NET host');
        }
        await globalClient.setProperty(this._id, propertyName, value);
    }

    /** Get an indexed value (e.g., dictionary[key]) */
    async getIndexer(key: string | number): Promise<unknown> {
        if (!globalClient) {
            throw new Error('No connection to .NET host');
        }
        const result = await globalClient.getIndexer(this._id, key);
        return wrapIfProxy(result);
    }

    /** Set an indexed value (e.g., dictionary[key] = value) */
    async setIndexer(key: string | number, value: unknown): Promise<void> {
        if (!globalClient) {
            throw new Error('No connection to .NET host');
        }
        await globalClient.setIndexer(this._id, key, value);
    }

    /** Release this object from the .NET registry */
    async dispose(): Promise<void> {
        if (!globalClient) {
            return;
        }
        await globalClient.unregisterObject(this._id);
    }
}

/**
 * A proxy for .NET List<T> or IList<T> collections.
 * Provides list-like operations: add, get, count, clear, etc.
 */
export class ListProxy<T = unknown> {
    constructor(private _proxy: DotNetProxy) {}

    /** Get the underlying proxy for advanced operations */
    get proxy(): DotNetProxy { return this._proxy; }

    /**
     * Add an item to the list
     */
    async add(item: T): Promise<void> {
        const args = { item };
        console.log(`ListProxy.add: calling Add with args =`, JSON.stringify(args));
        await this._proxy.invokeMethod('Add', args);
    }

    /**
     * Get an item by index
     */
    async get(index: number): Promise<T> {
        const result = await this._proxy.getIndexer(index);
        return result as T;
    }

    /**
     * Set an item at the specified index
     */
    async set(index: number, value: T): Promise<void> {
        await this._proxy.setIndexer(index, value);
    }

    /**
     * Get the number of items in the list
     */
    async count(): Promise<number> {
        const result = await this._proxy.getProperty('Count');
        return result as number;
    }

    /**
     * Remove all items from the list
     */
    async clear(): Promise<void> {
        await this._proxy.invokeMethod('Clear');
    }

    /**
     * Check if the list contains an item
     */
    async contains(item: T): Promise<boolean> {
        const result = await this._proxy.invokeMethod('Contains', { item });
        return result as boolean;
    }

    /**
     * Remove an item from the list
     */
    async remove(item: T): Promise<boolean> {
        const result = await this._proxy.invokeMethod('Remove', { item });
        return result as boolean;
    }

    /**
     * Remove an item at the specified index
     */
    async removeAt(index: number): Promise<void> {
        await this._proxy.invokeMethod('RemoveAt', { index });
    }

    /**
     * Insert an item at the specified index
     */
    async insert(index: number, item: T): Promise<void> {
        await this._proxy.invokeMethod('Insert', { index, item });
    }

    /**
     * Release the proxy reference
     */
    async dispose(): Promise<void> {
        await this._proxy.dispose();
    }
}

/**
 * Represents a ReferenceExpression that can be passed to .NET methods.
 * This is the result of using the `refExpr` tagged template literal.
 *
 * Serializes as a format string with {$id} placeholders for object references,
 * which .NET can easily reconstruct using ReferenceExpressionBuilder.
 */
export class ReferenceExpression {
    /** Marker to identify this as a ReferenceExpression for serialization */
    readonly $referenceExpression = true;

    constructor(
        /** The format string with {$id} placeholders */
        public readonly format: string
    ) {}

    /**
     * Converts to a serializable format for passing to .NET.
     */
    toJSON() {
        return {
            $referenceExpression: true,
            format: this.format
        };
    }
}

/**
 * Interface for proxy wrapper classes that have an underlying DotNetProxy.
 */
export interface HasProxy {
    proxy: DotNetProxy;
}

// ============================================================================
// ATS (Aspire Type System) Classes
// ============================================================================

/**
 * Error thrown when an ATS capability invocation fails.
 */
export class CapabilityError extends Error {
    constructor(
        /** The structured error from the server */
        public readonly error: AtsError
    ) {
        super(error.message);
        this.name = 'CapabilityError';
    }

    /** Machine-readable error code */
    get code(): string {
        return this.error.code;
    }

    /** The capability that failed (if applicable) */
    get capability(): string | undefined {
        return this.error.capability;
    }
}

/**
 * A typed handle to a .NET object in the ATS system.
 * Handles are opaque references that can be passed to capabilities.
 *
 * @typeParam T - The ATS type ID (e.g., "aspire/Builder")
 */
export class Handle<T extends string = string> {
    private readonly _handleId: string;
    private readonly _typeId: T;

    constructor(marshalled: MarshalledHandle) {
        this._handleId = marshalled.$handle;
        this._typeId = marshalled.$type as T;
    }

    /** The handle ID (format: "{typeId}:{instanceId}") */
    get $handle(): string {
        return this._handleId;
    }

    /** The ATS type ID */
    get $type(): T {
        return this._typeId;
    }

    /** Serialize for JSON-RPC transport */
    toJSON(): MarshalledHandle {
        return {
            $handle: this._handleId,
            $type: this._typeId
        };
    }

    /** String representation for debugging */
    toString(): string {
        return `Handle<${this._typeId}>(${this._handleId})`;
    }
}

/**
 * Interface for objects that have an underlying Handle.
 */
export interface HasHandle {
    handle: Handle;
}

/**
 * Type guard to check if a value has a proxy property.
 */
function hasProxy(value: unknown): value is HasProxy {
    return value !== null && typeof value === 'object' && 'proxy' in value && (value as HasProxy).proxy instanceof DotNetProxy;
}

/**
 * Tagged template literal for creating ReferenceExpression instances.
 *
 * DotNetProxy values (or proxy wrappers) are replaced with {$id} placeholders
 * that .NET uses to look up objects from the registry.
 *
 * Usage:
 * ```typescript
 * const endpoint = await redis.getEndpoint("tcp");
 * const password = await builder.addParameter("password", { secret: true });
 * const expr = refExpr`Host=${endpoint};Password=${password}`;
 * await resource.withEnvironment("CONNECTION_STRING", expr);
 * ```
 */
export function refExpr(strings: TemplateStringsArray, ...values: (DotNetProxy | HasProxy | string | number | boolean)[]): ReferenceExpression {
    let format = '';

    for (let i = 0; i < strings.length; i++) {
        format += strings[i];

        if (i < values.length) {
            const value = values[i];
            if (value instanceof DotNetProxy) {
                // Use the object's $id as a placeholder
                format += `{${value.$id}}`;
            } else if (hasProxy(value)) {
                // Proxy wrapper - use the underlying proxy's $id
                format += `{${value.proxy.$id}}`;
            } else {
                // Primitives are inlined as literals
                format += String(value);
            }
        }
    }

    return new ReferenceExpression(format);
}

/**
 * Checks if a value is a marshalled .NET object or handle and wraps it appropriately.
 */
export function wrapIfProxy(value: unknown): unknown {
    if (value && typeof value === 'object') {
        // Check for ATS handle (new system)
        if (isMarshalledHandle(value)) {
            return new Handle(value);
        }
        // Check for legacy proxy object
        if ('$id' in value && '$type' in value) {
            return new DotNetProxy(value as MarshalledObject);
        }
    }
    return value;
}

/**
 * Creates a proxy from a marshalled object received from .NET.
 */
export function createProxy(marshalled: MarshalledObject): DotNetProxy {
    return new DotNetProxy(marshalled);
}

export class RemoteAppHostClient {
    private connection: rpc.MessageConnection | null = null;
    private socket: net.Socket | null = null;
    private disconnectCallbacks: (() => void)[] = [];

    constructor(private socketPath: string) { }

    /**
     * Register a callback to be called when the connection is lost
     */
    onDisconnect(callback: () => void): void {
        this.disconnectCallbacks.push(callback);
    }

    private notifyDisconnect(): void {
        for (const callback of this.disconnectCallbacks) {
            try {
                callback();
            } catch {
                // Ignore callback errors
            }
        }
    }

    connect(timeoutMs: number = 5000): Promise<void> {
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => reject(new Error('Connection timeout')), timeoutMs);

            // On Windows, socket path is a named pipe; on Unix, it's a Unix domain socket path
            const isWindows = process.platform === 'win32';
            const pipePath = isWindows ? `\\\\.\\pipe\\${this.socketPath}` : this.socketPath;

            this.socket = net.createConnection(pipePath);

            this.socket.once('error', (error: Error) => {
                clearTimeout(timeout);
                reject(error);
            });

            this.socket.once('connect', () => {
                clearTimeout(timeout);
                try {
                    const reader = new rpc.SocketMessageReader(this.socket!);
                    const writer = new rpc.SocketMessageWriter(this.socket!);
                    this.connection = rpc.createMessageConnection(reader, writer);

                    this.connection.onClose(() => {
                        this.connection = null;
                        this.notifyDisconnect();
                    });
                    this.connection.onError((err: any) => console.error('JsonRpc connection error:', err));

                    // Handle callback invocations from the .NET side
                    this.connection.onRequest('invokeCallback', async (callbackId: string, args: unknown) => {
                        const callback = callbackRegistry.get(callbackId);
                        if (!callback) {
                            throw new Error(`Callback not found: ${callbackId}`);
                        }
                        try {
                            // The registered wrapper handles arg unpacking and proxy wrapping
                            return await Promise.resolve(callback(args));
                        } catch (error) {
                            const message = error instanceof Error ? error.message : String(error);
                            throw new Error(`Callback execution failed: ${message}`);
                        }
                    });

                    this.connection.listen();

                    // Set global client reference for proxy objects
                    globalClient = this;

                    resolve();
                } catch (e) {
                    reject(e);
                }
            });

            this.socket.on('close', () => {
                this.connection?.dispose();
                this.connection = null;
                this.notifyDisconnect();
            });
        });
    }

    ping(): Promise<string> {
        if (!this.connection) return Promise.reject(new Error('Not connected to RemoteAppHost'));
        return this.connection.sendRequest('ping');
    }

    /** Authenticate with the server using the provided token */
    authenticate(token: string): Promise<boolean> {
        if (!this.connection) return Promise.reject(new Error('Not connected to RemoteAppHost'));
        return this.connection.sendRequest('authenticate', token);
    }

    /** Invoke a method on a .NET object (instance methods only) */
    invokeMethod(objectId: string, methodName: string, args?: Record<string, unknown>): Promise<unknown> {
        if (!this.connection) return Promise.reject(new Error('Not connected to RemoteAppHost'));
        return this.connection.sendRequest('invokeMethod', objectId, methodName, args ?? null);
    }

    /** Invoke a static method on a .NET type */
    invokeStaticMethod(assemblyName: string, typeName: string, methodName: string, args?: Record<string, unknown>): Promise<unknown> {
        if (!this.connection) return Promise.reject(new Error('Not connected to RemoteAppHost'));
        return this.connection.sendRequest('invokeStaticMethod', assemblyName, typeName, methodName, args ?? null);
    }

    /** Create an instance of a .NET type */
    createObject(assemblyName: string, typeName: string, args?: Record<string, unknown>): Promise<unknown> {
        if (!this.connection) return Promise.reject(new Error('Not connected to RemoteAppHost'));
        return this.connection.sendRequest('createObject', assemblyName, typeName, args ?? null);
    }

    /** Get a property from a .NET object */
    getProperty(objectId: string, propertyName: string): Promise<unknown> {
        if (!this.connection) return Promise.reject(new Error('Not connected to RemoteAppHost'));
        return this.connection.sendRequest('getProperty', objectId, propertyName);
    }

    /** Set a property on a .NET object */
    setProperty(objectId: string, propertyName: string, value: unknown): Promise<void> {
        if (!this.connection) return Promise.reject(new Error('Not connected to RemoteAppHost'));
        return this.connection.sendRequest('setProperty', objectId, propertyName, value);
    }

    /** Get an indexed value from a .NET object */
    getIndexer(objectId: string, key: string | number): Promise<unknown> {
        if (!this.connection) return Promise.reject(new Error('Not connected to RemoteAppHost'));
        return this.connection.sendRequest('getIndexer', objectId, key);
    }

    /** Set an indexed value on a .NET object */
    setIndexer(objectId: string, key: string | number, value: unknown): Promise<void> {
        if (!this.connection) return Promise.reject(new Error('Not connected to RemoteAppHost'));
        return this.connection.sendRequest('setIndexer', objectId, key, value);
    }

    /** Unregister an object from the .NET registry */
    unregisterObject(objectId: string): Promise<void> {
        if (!this.connection) return Promise.reject(new Error('Not connected to RemoteAppHost'));
        return this.connection.sendRequest('unregisterObject', objectId);
    }

    /** Get a static property from a .NET type */
    getStaticProperty(assemblyName: string, typeName: string, propertyName: string): Promise<unknown> {
        if (!this.connection) return Promise.reject(new Error('Not connected to RemoteAppHost'));
        return this.connection.sendRequest('getStaticProperty', assemblyName, typeName, propertyName);
    }

    /** Set a static property on a .NET type */
    setStaticProperty(assemblyName: string, typeName: string, propertyName: string, value: unknown): Promise<void> {
        if (!this.connection) return Promise.reject(new Error('Not connected to RemoteAppHost'));
        return this.connection.sendRequest('setStaticProperty', assemblyName, typeName, propertyName, value);
    }

    // ========================================================================
    // ATS Capability Methods
    // ========================================================================

    /**
     * Invoke an ATS capability by ID.
     *
     * Capabilities are versioned operations exposed by [AspireExport] attributes.
     * Results are automatically wrapped in Handle objects when applicable.
     *
     * @param capabilityId - The capability ID (e.g., "aspire/createBuilder@1")
     * @param args - Arguments to pass to the capability
     * @returns The capability result, wrapped as Handle if it's a handle type
     * @throws CapabilityError if the capability fails
     *
     * @example
     * ```typescript
     * const builder = await client.invokeCapability<Handle<'aspire/Builder'>>(
     *     'aspire/createBuilder@1',
     *     {}
     * );
     * const redis = await client.invokeCapability<Handle<'aspire.redis/RedisBuilder'>>(
     *     'aspire.redis/addRedis@1',
     *     { builder, name: 'cache' }
     * );
     * ```
     */
    async invokeCapability<T = unknown>(
        capabilityId: string,
        args?: Record<string, unknown>
    ): Promise<T> {
        if (!this.connection) {
            throw new Error('Not connected to RemoteAppHost');
        }

        const result = await this.connection.sendRequest(
            'invokeCapability',
            capabilityId,
            args ?? null
        );

        // Check for structured error response
        if (isAtsError(result)) {
            throw new CapabilityError(result.$error);
        }

        // Wrap handles automatically
        return wrapIfProxy(result) as T;
    }

    /**
     * Get the list of available capability IDs from the server.
     *
     * @returns Array of capability IDs (e.g., ["aspire/createBuilder@1", "aspire.redis/addRedis@1"])
     *
     * @example
     * ```typescript
     * const capabilities = await client.getCapabilities();
     * console.log('Available:', capabilities.join(', '));
     * ```
     */
    async getCapabilities(): Promise<string[]> {
        if (!this.connection) {
            throw new Error('Not connected to RemoteAppHost');
        }
        return await this.connection.sendRequest('getCapabilities');
    }

    disconnect(): void {
        globalClient = null;
        try { this.connection?.dispose(); } finally { this.connection = null; }
        try { this.socket?.end(); } finally { this.socket = null; }
    }

    get connected(): boolean {
        return this.connection !== null && this.socket !== null;
    }
}

// Re-export ATS types for convenience
// Use 'export type' for interfaces (type-only exports) to work with isolatedModules
export type { MarshalledHandle, AtsError, AtsErrorDetails } from './types.js';
export { AtsErrorCodes, isAtsError, isMarshalledHandle } from './types.js';
,
  types.ts:
/**
 * Type for callback functions that can be registered and invoked from .NET.
 */
export type CallbackFunction = (args: unknown) => unknown | Promise<unknown>;

/**
 * Represents a marshalled .NET object received over JSON-RPC.
 * Contains the object ID for RPC calls and metadata about the object.
 */
export interface MarshalledObject {
    /** The object ID in the .NET object registry */
    $id: string;
    /** The .NET type name */
    $type: string;
    /** The full .NET type name including namespace */
    $fullType?: string;
    /** Available methods on the object */
    $methods?: Array<{
        name: string;
        parameters: Array<{ name: string; type: string }>;
    }>;
    /** Additional properties with their values (simple types) or type info (complex types) */
    [key: string]: unknown;
}

// ============================================================================
// ATS (Aspire Type System) Types
// ============================================================================

/**
 * Represents a handle to a .NET object in the ATS system.
 * Handles are typed references that can be passed between capabilities.
 */
export interface MarshalledHandle {
    /** The handle ID (format: "{typeId}:{instanceId}") */
    $handle: string;
    /** The ATS type ID (e.g., "aspire/Builder", "aspire.redis/RedisBuilder") */
    $type: string;
}

/**
 * Error details for ATS errors.
 */
export interface AtsErrorDetails {
    /** The parameter that caused the error */
    parameter?: string;
    /** The expected type or value */
    expected?: string;
    /** The actual type or value */
    actual?: string;
}

/**
 * Structured error from ATS capability invocation.
 */
export interface AtsError {
    /** Machine-readable error code */
    code: string;
    /** Human-readable error message */
    message: string;
    /** The capability that failed (if applicable) */
    capability?: string;
    /** Additional error details */
    details?: AtsErrorDetails;
}

/**
 * ATS error codes returned by the server.
 */
export const AtsErrorCodes = {
    /** Unknown capability ID */
    CapabilityNotFound: 'CAPABILITY_NOT_FOUND',
    /** Handle ID doesn't exist or was disposed */
    HandleNotFound: 'HANDLE_NOT_FOUND',
    /** Handle type doesn't satisfy capability's AppliesTo constraint */
    TypeMismatch: 'TYPE_MISMATCH',
    /** Missing required argument or wrong type */
    InvalidArgument: 'INVALID_ARGUMENT',
    /** Argument value outside valid range */
    ArgumentOutOfRange: 'ARGUMENT_OUT_OF_RANGE',
    /** Error occurred during callback invocation */
    CallbackError: 'CALLBACK_ERROR',
    /** Unexpected error in capability execution */
    InternalError: 'INTERNAL_ERROR',
} as const;

/**
 * Type guard to check if a value is an ATS error response.
 */
export function isAtsError(value: unknown): value is { $error: AtsError } {
    return (
        value !== null &&
        typeof value === 'object' &&
        '$error' in value &&
        typeof (value as { $error: unknown }).$error === 'object'
    );
}

/**
 * Type guard to check if a value is a marshalled handle.
 */
export function isMarshalledHandle(value: unknown): value is MarshalledHandle {
    return (
        value !== null &&
        typeof value === 'object' &&
        '$handle' in value &&
        '$type' in value
    );
}

}