{
  distributed-application.ts:
import { RemoteAppHostClient, registerCallback, DotNetProxy, ListProxy, wrapIfProxy } from './RemoteAppHostClient.js';

// Get socket path from environment variable (set by aspire run)
const socketPath = process.env.REMOTE_APP_HOST_SOCKET_PATH;
if (!socketPath) {
    throw new Error('REMOTE_APP_HOST_SOCKET_PATH environment variable not set. Please run with "aspire run".');
}

const client = new RemoteAppHostClient(socketPath);

export async function createBuilder(args: string[] = process.argv.slice(2)): Promise<DistributedApplicationBuilder> {
    console.log('ðŸ”Œ Connecting to AppHost server...');

    while (true) {
      try {
        await client.connect();
        await client.ping();
        console.log('âœ… Connected successfully!');
        break;
      } catch (error) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    // Use static INVOKE to call DistributedApplication.CreateBuilder(options)
    const result = await client.invokeStaticMethod('Aspire.Hosting', 'Aspire.Hosting.DistributedApplication', 'CreateBuilder', {
      options: {
        Args: args,
        ProjectDirectory: process.cwd()
      }
    });

    if (result && typeof result === 'object' && '$id' in result) {
      return new DistributedApplicationBuilder(new DotNetProxy(result as any));
    }

    throw new Error('Failed to create DistributedApplicationBuilder');
}

export class DistributedApplication {
  private _appProxy: DotNetProxy | null = null;

  constructor(private builderProxy: DotNetProxy | null) {
  }

  /**
   * Gets the Services property (IServiceProvider).
   * Use this to resolve services after the application is built and running.
   */
  async getServices(): Promise<ServiceProviderProxy> {
    if (!this._appProxy) {
      throw new Error('Application not yet running. Call run() first.');
    }
    const services = await this._appProxy.getProperty('Services') as DotNetProxy;
    return new ServiceProviderProxy(services);
  }

  async run() {
    // Build the application using invokeMethod
    const buildResult = await this.builderProxy?.invokeMethod('Build', {});

    // Store the app proxy for service resolution
    if (buildResult && typeof buildResult === 'object' && '$id' in buildResult) {
      this._appProxy = new DotNetProxy(buildResult as any);
    }

    // Run the application using invokeMethod
    // This returns a Task that completes when the app stops
    const runPromise = this._appProxy?.invokeMethod('RunAsync', {});

    // Wait for either Ctrl+C, SIGTERM, or the connection to close
    await new Promise<void>((resolve) => {
      const shutdown = async () => {
        console.log("\nStopping application...");
        try {
          // Try to stop the app gracefully
          await this._appProxy?.invokeMethod('StopAsync', {});
        } catch {
          // Ignore errors during shutdown
        }
        client.disconnect();
        resolve();
      };

      // Handle Ctrl+C for graceful shutdown
      process.on("SIGINT", shutdown);

      // Handle SIGTERM (sent by CLI on shutdown)
      process.on("SIGTERM", shutdown);

      // Handle connection close (GenericAppHost exited after publish)
      client.onDisconnect(() => {
        resolve();
      });

      // Also resolve when runPromise completes
      runPromise?.then(() => resolve()).catch(() => resolve());
    });

    process.exit(0);
  }
}

/**
 * Strongly-typed proxy for IConfiguration.
 * Provides natural access to configuration values.
 */
export class ConfigurationProxy {
  constructor(private _proxy: DotNetProxy) {}

  /** Get the underlying proxy for advanced operations */
  get proxy(): DotNetProxy { return this._proxy; }

  /**
   * Gets a configuration value by key.
   * @param key The configuration key (e.g., "Logging:LogLevel:Default")
   */
  async get(key: string): Promise<string | null> {
    const result = await this._proxy.getIndexer(key);
    return result as string | null;
  }

  /**
   * Gets a configuration section.
   * @param key The section key
   */
  async getSection(key: string): Promise<ConfigurationProxy> {
    const result = await this._proxy.invokeMethod('GetSection', { key });
    return new ConfigurationProxy(result as DotNetProxy);
  }

  /**
   * Gets a connection string by name.
   * @param name The connection string name
   */
  async getConnectionString(name: string): Promise<string | null> {
    const result = await this._proxy.invokeMethod('GetConnectionString', { name });
    return result as string | null;
  }

  /**
   * Gets the key of this configuration section.
   */
  async getKey(): Promise<string> {
    return await this._proxy.getProperty('Key') as string;
  }

  /**
   * Gets the path of this configuration section.
   */
  async getPath(): Promise<string> {
    return await this._proxy.getProperty('Path') as string;
  }

  /**
   * Gets the value of this configuration section.
   */
  async getValue(): Promise<string | null> {
    return await this._proxy.getProperty('Value') as string | null;
  }
}

/**
 * Strongly-typed proxy for IHostEnvironment.
 * Provides natural access to environment information.
 */
export class HostEnvironmentProxy {
  constructor(private _proxy: DotNetProxy) {}

  /** Get the underlying proxy for advanced operations */
  get proxy(): DotNetProxy { return this._proxy; }

  /**
   * Gets the name of the environment (e.g., "Development", "Production").
   */
  async getEnvironmentName(): Promise<string> {
    return await this._proxy.getProperty('EnvironmentName') as string;
  }

  /**
   * Gets the name of the application.
   */
  async getApplicationName(): Promise<string> {
    return await this._proxy.getProperty('ApplicationName') as string;
  }

  /**
   * Gets the content root path.
   */
  async getContentRootPath(): Promise<string> {
    return await this._proxy.getProperty('ContentRootPath') as string;
  }

  /**
   * Checks if the environment is Development.
   */
  async isDevelopment(): Promise<boolean> {
    const envName = await this.getEnvironmentName();
    return envName === 'Development';
  }

  /**
   * Checks if the environment is Production.
   */
  async isProduction(): Promise<boolean> {
    const envName = await this.getEnvironmentName();
    return envName === 'Production';
  }

  /**
   * Checks if the environment is Staging.
   */
  async isStaging(): Promise<boolean> {
    const envName = await this.getEnvironmentName();
    return envName === 'Staging';
  }

  /**
   * Checks if the environment matches the specified name.
   */
  async isEnvironment(environmentName: string): Promise<boolean> {
    const envName = await this.getEnvironmentName();
    return envName.toLowerCase() === environmentName.toLowerCase();
  }
}

/**
 * Strongly-typed proxy for DistributedApplicationExecutionContext.
 * Provides access to execution context information.
 */
export class ExecutionContextProxy {
  constructor(private _proxy: DotNetProxy) {}

  /** Get the underlying proxy for advanced operations */
  get proxy(): DotNetProxy { return this._proxy; }

  /**
   * Checks if the application is running in run mode.
   */
  async isRunMode(): Promise<boolean> {
    return await this._proxy.getProperty('IsRunMode') as boolean;
  }

  /**
   * Checks if the application is running in publish mode.
   */
  async isPublishMode(): Promise<boolean> {
    return await this._proxy.getProperty('IsPublishMode') as boolean;
  }

  /**
   * Gets the operation being performed (Run or Publish).
   */
  async getOperation(): Promise<string> {
    return await this._proxy.getProperty('Operation') as string;
  }
}

/**
 * Strongly-typed proxy for ILoggerFactory.
 * Provides natural access to logging functionality.
 */
export class LoggerFactoryProxy {
  constructor(private _proxy: DotNetProxy) {}

  /** Get the underlying proxy for advanced operations */
  get proxy(): DotNetProxy { return this._proxy; }

  /**
   * Creates a logger with the specified category name.
   * @param categoryName The category name for the logger
   */
  async createLogger(categoryName: string): Promise<LoggerProxy> {
    const result = await this._proxy.invokeMethod('CreateLogger', { categoryName });
    return new LoggerProxy(result as DotNetProxy);
  }
}

/**
 * Strongly-typed proxy for ILogger.
 * Provides natural logging methods.
 */
export class LoggerProxy {
  constructor(private _proxy: DotNetProxy) {}

  /** Get the underlying proxy for advanced operations */
  get proxy(): DotNetProxy { return this._proxy; }

  /**
   * Logs an informational message.
   */
  async logInformation(message: string): Promise<void> {
    await this._proxy.invokeMethod('Log', { logLevel: 2, message });
  }

  /**
   * Logs a warning message.
   */
  async logWarning(message: string): Promise<void> {
    await this._proxy.invokeMethod('Log', { logLevel: 3, message });
  }

  /**
   * Logs an error message.
   */
  async logError(message: string): Promise<void> {
    await this._proxy.invokeMethod('Log', { logLevel: 4, message });
  }

  /**
   * Logs a debug message.
   */
  async logDebug(message: string): Promise<void> {
    await this._proxy.invokeMethod('Log', { logLevel: 1, message });
  }
}

/**
 * Proxy for IServiceProvider to resolve services after build.
 * Supports well-known type aliases (e.g., "IConfiguration") and full type names.
 */
export class ServiceProviderProxy {
  constructor(private _proxy: DotNetProxy) {}

  /** Get the underlying proxy for advanced operations */
  get proxy(): DotNetProxy { return this._proxy; }

  /**
   * Gets a service of the specified type.
   * @param typeName Type name - full type name required
   * @returns The resolved service proxy or null if not found
   */
  async getService(typeName: string): Promise<DotNetProxy | null> {
    const result = await this._proxy.invokeMethod('GetService', { serviceType: typeName });
    if (result === null || result === undefined) {
      return null;
    }
    return new DotNetProxy(result as any);
  }

  /**
   * Gets a required service of the specified type.
   * @param typeName Type name - full type name required
   * @throws Error if the service is not found
   */
  async getRequiredService(typeName: string): Promise<DotNetProxy> {
    const result = await this._proxy.invokeMethod('GetRequiredService', { serviceType: typeName });
    return new DotNetProxy(result as any);
  }

  /**
   * Gets the IConfiguration service.
   */
  async getConfiguration(): Promise<ConfigurationProxy> {
    const result = await this._proxy.invokeMethod('GetRequiredService', { serviceType: 'Microsoft.Extensions.Configuration.IConfiguration' });
    return new ConfigurationProxy(new DotNetProxy(result as any));
  }

  /**
   * Gets the IHostEnvironment service.
   */
  async getHostEnvironment(): Promise<HostEnvironmentProxy> {
    const result = await this._proxy.invokeMethod('GetRequiredService', { serviceType: 'Microsoft.Extensions.Hosting.IHostEnvironment' });
    return new HostEnvironmentProxy(new DotNetProxy(result as any));
  }

  /**
   * Gets the ILoggerFactory service.
   */
  async getLoggerFactory(): Promise<LoggerFactoryProxy> {
    const result = await this._proxy.invokeMethod('GetRequiredService', { serviceType: 'Microsoft.Extensions.Logging.ILoggerFactory' });
    return new LoggerFactoryProxy(new DotNetProxy(result as any));
  }
}

abstract class DistributedApplicationBuilderBase {
  constructor(protected _proxy: DotNetProxy) {
  }

  /** Gets the underlying builder proxy */
  get proxy(): DotNetProxy {
    return this._proxy;
  }

  /**
   * Gets the Configuration property (ConfigurationManager).
   * Use this to read configuration values before building the application.
   */
  async getConfiguration(): Promise<ConfigurationProxy> {
    const result = await this._proxy.getProperty('Configuration') as DotNetProxy;
    return new ConfigurationProxy(result);
  }

  /**
   * Gets the Environment property (IHostEnvironment).
   * Use this to check environment name, application name, etc.
   */
  async getEnvironment(): Promise<HostEnvironmentProxy> {
    const result = await this._proxy.getProperty('Environment') as DotNetProxy;
    return new HostEnvironmentProxy(result);
  }

  /**
   * Gets the ExecutionContext property (DistributedApplicationExecutionContext).
   * Use this to check if running in run mode vs publish mode.
   */
  async getExecutionContext(): Promise<ExecutionContextProxy> {
    const result = await this._proxy.getProperty('ExecutionContext') as DotNetProxy;
    return new ExecutionContextProxy(result);
  }

  /**
   * Checks if the application is running in the Development environment.
   */
  async isDevelopment(): Promise<boolean> {
    const env = await this.getEnvironment();
    return await env.isDevelopment();
  }

  /**
   * Checks if the application is running in the Production environment.
   */
  async isProduction(): Promise<boolean> {
    const env = await this.getEnvironment();
    return await env.isProduction();
  }

  /**
   * Checks if the execution context is in run mode (vs publish mode).
   */
  async isRunMode(): Promise<boolean> {
    const ctx = await this.getExecutionContext();
    return await ctx.isRunMode();
  }

  /**
   * Checks if the execution context is in publish mode.
   */
  async isPublishMode(): Promise<boolean> {
    const ctx = await this.getExecutionContext();
    return await ctx.isPublishMode();
  }

  /**
   * Gets the Services property (IServiceCollection).
   * Use this to register additional services before building.
   */
  async getServices(): Promise<DotNetProxy> {
    return await this._proxy.getProperty('Services') as DotNetProxy;
  }

  build() {
    return new DistributedApplication(this._proxy);
  }
}
export class DistributedApplicationBuilder extends DistributedApplicationBuilderBase {

   /**
   * AddTestRedis
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> AddTestRedis(IDistributedApplicationBuilder builder, String name, Nullable<Int32> port)
   * @param {string} name C# Type: String
   * @param {number | null} port C# Type: Nullable<Int32>
   * @returns {TestRedisResourceBuilder} C# Type: IResourceBuilder<TestRedisResource>
   */
  /** @internal */
  async _addTestRedisInternal(name: string, port?: number | null) : Promise<TestRedisResourceBuilder> {
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'AddTestRedis', {builder: this._proxy, name: name, port: port || null});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestRedisResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('AddTestRedis did not return a marshalled object');
  };

  /**
   * AddTestRedis (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> AddTestRedis(IDistributedApplicationBuilder builder, String name, Nullable<Int32> port)
   */
  addTestRedis(name: string, port?: number | null): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(this._addTestRedisInternal(name, port));
  }

   /**
   * AddTestDatabase
   * @remarks C# Definition: IResourceBuilder<TestDatabaseResource> AddTestDatabase(IDistributedApplicationBuilder builder, String name, String databaseName)
   * @param {string} name C# Type: String
   * @param {string} databaseName C# Type: String
   * @returns {TestDatabaseResourceBuilder} C# Type: IResourceBuilder<TestDatabaseResource>
   */
  /** @internal */
  async _addTestDatabaseInternal(name: string, databaseName?: string) : Promise<TestDatabaseResourceBuilder> {
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'AddTestDatabase', {builder: this._proxy, name: name, databaseName: databaseName || null});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestDatabaseResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('AddTestDatabase did not return a marshalled object');
  };

  /**
   * AddTestDatabase (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestDatabaseResource> AddTestDatabase(IDistributedApplicationBuilder builder, String name, String databaseName)
   */
  addTestDatabase(name: string, databaseName?: string): TestDatabaseResourceBuilderPromise {
    return new TestDatabaseResourceBuilderPromise(this._addTestDatabaseInternal(name, databaseName));
  }
}
export class IResourceWithConnectionStringBuilder {
  constructor(protected _proxy: DotNetProxy) {}

  /** Gets the underlying proxy */
  get proxy(): DotNetProxy { return this._proxy; }
}

/**
 * Thenable wrapper for IResourceWithConnectionStringBuilder that enables fluent chaining.
 */
export class IResourceWithConnectionStringBuilderPromise implements PromiseLike<IResourceWithConnectionStringBuilder> {
  constructor(private _promise: Promise<IResourceWithConnectionStringBuilder>) {}

  then<TResult1 = IResourceWithConnectionStringBuilder, TResult2 = never>(
    onfulfilled?: ((value: IResourceWithConnectionStringBuilder) => TResult1 | PromiseLike<TResult1>) | null,
    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null
  ): PromiseLike<TResult1 | TResult2> {
    return this._promise.then(onfulfilled, onrejected);
  }
}

export class ResourceBuilder {
  constructor(protected _proxy: DotNetProxy) {}

  /** Gets the underlying proxy */
  get proxy(): DotNetProxy { return this._proxy; }
}

/**
 * Thenable wrapper for ResourceBuilder that enables fluent chaining.
 */
export class ResourceBuilderPromise implements PromiseLike<ResourceBuilder> {
  constructor(private _promise: Promise<ResourceBuilder>) {}

  then<TResult1 = ResourceBuilder, TResult2 = never>(
    onfulfilled?: ((value: ResourceBuilder) => TResult1 | PromiseLike<TResult1>) | null,
    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null
  ): PromiseLike<TResult1 | TResult2> {
    return this._promise.then(onfulfilled, onrejected);
  }
}

export class TestRedisResourceBuilder {
  constructor(protected _proxy: DotNetProxy) {}

  /** Gets the underlying proxy */
  get proxy(): DotNetProxy { return this._proxy; }

   /**
   * WithPersistence
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithPersistence(IResourceBuilder<TestRedisResource> builder, TestPersistenceMode mode)
   * @param {TestPersistenceMode} mode C# Type: TestPersistenceMode
   * @returns {TestRedisResourceBuilder} C# Type: IResourceBuilder<TestRedisResource>
   */
  /** @internal */
  async _withPersistenceInternal(mode?: TestPersistenceMode) : Promise<TestRedisResourceBuilder> {
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithPersistence', {builder: this._proxy, mode: mode || null});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestRedisResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithPersistence did not return a marshalled object');
  };

  /**
   * WithPersistence (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithPersistence(IResourceBuilder<TestRedisResource> builder, TestPersistenceMode mode)
   */
  withPersistence(mode?: TestPersistenceMode): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(this._withPersistenceInternal(mode));
  }

   /**
   * WithBuilderCallback
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithBuilderCallback(IResourceBuilder<TestRedisResource> builder, Action<IResourceBuilder<TestRedisResource>> configure)
   * @param {(p0: TestRedisResourceBuilder) => void | Promise<void>} configure C# Type: Action<IResourceBuilder<TestRedisResource>>
   * @returns {TestRedisResourceBuilder} C# Type: IResourceBuilder<TestRedisResource>
   */
  /** @internal */
  async _withBuilderCallbackInternal(configure?: (p0: TestRedisResourceBuilder) => void | Promise<void>) : Promise<TestRedisResourceBuilder> {
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithBuilderCallback', {builder: this._proxy, configure: configure ? registerCallback((arg: DotNetProxy) => configure(new TestRedisResourceBuilder(arg))) : null});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestRedisResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithBuilderCallback did not return a marshalled object');
  };

  /**
   * WithBuilderCallback (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithBuilderCallback(IResourceBuilder<TestRedisResource> builder, Action<IResourceBuilder<TestRedisResource>> configure)
   */
  withBuilderCallback(configure?: (p0: TestRedisResourceBuilder) => void | Promise<void>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(this._withBuilderCallbackInternal(configure));
  }

   /**
   * WithCustomCallback
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithCustomCallback<TestRedisResource>(IResourceBuilder<T> builder, Action<TestCallbackContext> callback)
   * @param {(p0: TestCallbackContextProxy) => void | Promise<void>} callback C# Type: Action<TestCallbackContext>
   * @returns {TestRedisResourceBuilder} C# Type: IResourceBuilder<TestRedisResource>
   */
  /** @internal */
  async _withCustomCallbackInternal(callback: (p0: TestCallbackContextProxy) => void | Promise<void>) : Promise<TestRedisResourceBuilder> {
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithCustomCallback', {builder: this._proxy, callback: registerCallback((arg: DotNetProxy) => callback(new TestCallbackContextProxy(arg)))});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestRedisResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithCustomCallback did not return a marshalled object');
  };

  /**
   * WithCustomCallback (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithCustomCallback<TestRedisResource>(IResourceBuilder<T> builder, Action<TestCallbackContext> callback)
   */
  withCustomCallback(callback: (p0: TestCallbackContextProxy) => void | Promise<void>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(this._withCustomCallbackInternal(callback));
  }

   /**
   * WithOptionalString
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithOptionalString<TestRedisResource>(IResourceBuilder<T> builder, String value, Boolean enabled)
   * @param {string} value C# Type: String
   * @param {boolean} enabled C# Type: Boolean
   * @returns {TestRedisResourceBuilder} C# Type: IResourceBuilder<TestRedisResource>
   */
  /** @internal */
  async _withOptionalStringInternal(optionalArguments: WithOptionalStringArgs = new WithOptionalStringArgs()) : Promise<TestRedisResourceBuilder> {
    optionalArguments = Object.assign(new WithOptionalStringArgs(), optionalArguments);
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithOptionalString', {builder: this._proxy, value: optionalArguments?.value || null, enabled: optionalArguments?.enabled || null});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestRedisResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithOptionalString did not return a marshalled object');
  };

  /**
   * WithOptionalString (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithOptionalString<TestRedisResource>(IResourceBuilder<T> builder, String value, Boolean enabled)
   */
  withOptionalString(optionalArguments: WithOptionalStringArgs = new WithOptionalStringArgs()): TestRedisResourceBuilderPromise {
    optionalArguments = Object.assign(new WithOptionalStringArgs(), optionalArguments);
    return new TestRedisResourceBuilderPromise(this._withOptionalStringInternal(optionalArguments));
  }

   /**
   * WithMultipleDefaults
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithMultipleDefaults<TestRedisResource>(IResourceBuilder<T> builder, Int32 count, String prefix, Boolean useUpperCase, Double multiplier)
   * @param {number} count C# Type: Int32
   * @param {string} prefix C# Type: String
   * @param {boolean} useUpperCase C# Type: Boolean
   * @param {number} multiplier C# Type: Double
   * @returns {TestRedisResourceBuilder} C# Type: IResourceBuilder<TestRedisResource>
   */
  /** @internal */
  async _withMultipleDefaultsInternal(optionalArguments: WithMultipleDefaultsArgs = new WithMultipleDefaultsArgs()) : Promise<TestRedisResourceBuilder> {
    optionalArguments = Object.assign(new WithMultipleDefaultsArgs(), optionalArguments);
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithMultipleDefaults', {builder: this._proxy, count: optionalArguments?.count || null, prefix: optionalArguments?.prefix || null, useUpperCase: optionalArguments?.useUpperCase || null, multiplier: optionalArguments?.multiplier || null});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestRedisResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithMultipleDefaults did not return a marshalled object');
  };

  /**
   * WithMultipleDefaults (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestRedisResource> WithMultipleDefaults<TestRedisResource>(IResourceBuilder<T> builder, Int32 count, String prefix, Boolean useUpperCase, Double multiplier)
   */
  withMultipleDefaults(optionalArguments: WithMultipleDefaultsArgs = new WithMultipleDefaultsArgs()): TestRedisResourceBuilderPromise {
    optionalArguments = Object.assign(new WithMultipleDefaultsArgs(), optionalArguments);
    return new TestRedisResourceBuilderPromise(this._withMultipleDefaultsInternal(optionalArguments));
  }
}

export class TestDatabaseResourceBuilder {
  constructor(protected _proxy: DotNetProxy) {}

  /** Gets the underlying proxy */
  get proxy(): DotNetProxy { return this._proxy; }

   /**
   * WithCustomCallback
   * @remarks C# Definition: IResourceBuilder<TestDatabaseResource> WithCustomCallback<TestDatabaseResource>(IResourceBuilder<T> builder, Action<TestCallbackContext> callback)
   * @param {(p0: TestCallbackContextProxy) => void | Promise<void>} callback C# Type: Action<TestCallbackContext>
   * @returns {TestDatabaseResourceBuilder} C# Type: IResourceBuilder<TestDatabaseResource>
   */
  /** @internal */
  async _withCustomCallbackInternal(callback: (p0: TestCallbackContextProxy) => void | Promise<void>) : Promise<TestDatabaseResourceBuilder> {
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithCustomCallback', {builder: this._proxy, callback: registerCallback((arg: DotNetProxy) => callback(new TestCallbackContextProxy(arg)))});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestDatabaseResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithCustomCallback did not return a marshalled object');
  };

  /**
   * WithCustomCallback (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestDatabaseResource> WithCustomCallback<TestDatabaseResource>(IResourceBuilder<T> builder, Action<TestCallbackContext> callback)
   */
  withCustomCallback(callback: (p0: TestCallbackContextProxy) => void | Promise<void>): TestDatabaseResourceBuilderPromise {
    return new TestDatabaseResourceBuilderPromise(this._withCustomCallbackInternal(callback));
  }

   /**
   * WithOptionalString
   * @remarks C# Definition: IResourceBuilder<TestDatabaseResource> WithOptionalString<TestDatabaseResource>(IResourceBuilder<T> builder, String value, Boolean enabled)
   * @param {string} value C# Type: String
   * @param {boolean} enabled C# Type: Boolean
   * @returns {TestDatabaseResourceBuilder} C# Type: IResourceBuilder<TestDatabaseResource>
   */
  /** @internal */
  async _withOptionalStringInternal(optionalArguments: WithOptionalStringArgs1 = new WithOptionalStringArgs1()) : Promise<TestDatabaseResourceBuilder> {
    optionalArguments = Object.assign(new WithOptionalStringArgs1(), optionalArguments);
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithOptionalString', {builder: this._proxy, value: optionalArguments?.value || null, enabled: optionalArguments?.enabled || null});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestDatabaseResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithOptionalString did not return a marshalled object');
  };

  /**
   * WithOptionalString (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestDatabaseResource> WithOptionalString<TestDatabaseResource>(IResourceBuilder<T> builder, String value, Boolean enabled)
   */
  withOptionalString(optionalArguments: WithOptionalStringArgs1 = new WithOptionalStringArgs1()): TestDatabaseResourceBuilderPromise {
    optionalArguments = Object.assign(new WithOptionalStringArgs1(), optionalArguments);
    return new TestDatabaseResourceBuilderPromise(this._withOptionalStringInternal(optionalArguments));
  }

   /**
   * WithMultipleDefaults
   * @remarks C# Definition: IResourceBuilder<TestDatabaseResource> WithMultipleDefaults<TestDatabaseResource>(IResourceBuilder<T> builder, Int32 count, String prefix, Boolean useUpperCase, Double multiplier)
   * @param {number} count C# Type: Int32
   * @param {string} prefix C# Type: String
   * @param {boolean} useUpperCase C# Type: Boolean
   * @param {number} multiplier C# Type: Double
   * @returns {TestDatabaseResourceBuilder} C# Type: IResourceBuilder<TestDatabaseResource>
   */
  /** @internal */
  async _withMultipleDefaultsInternal(optionalArguments: WithMultipleDefaultsArgs1 = new WithMultipleDefaultsArgs1()) : Promise<TestDatabaseResourceBuilder> {
    optionalArguments = Object.assign(new WithMultipleDefaultsArgs1(), optionalArguments);
    const result = await client.invokeStaticMethod('Aspire.Hosting.CodeGeneration.TypeScript.Tests', 'Aspire.Hosting.CodeGeneration.TypeScript.Tests.TestTypes.TestExtensions', 'WithMultipleDefaults', {builder: this._proxy, count: optionalArguments?.count || null, prefix: optionalArguments?.prefix || null, useUpperCase: optionalArguments?.useUpperCase || null, multiplier: optionalArguments?.multiplier || null});
    if (result && typeof result === 'object' && '$id' in result) {
        return new TestDatabaseResourceBuilder(new DotNetProxy(result as any));
    }
    throw new Error('WithMultipleDefaults did not return a marshalled object');
  };

  /**
   * WithMultipleDefaults (fluent chaining)
   * @remarks C# Definition: IResourceBuilder<TestDatabaseResource> WithMultipleDefaults<TestDatabaseResource>(IResourceBuilder<T> builder, Int32 count, String prefix, Boolean useUpperCase, Double multiplier)
   */
  withMultipleDefaults(optionalArguments: WithMultipleDefaultsArgs1 = new WithMultipleDefaultsArgs1()): TestDatabaseResourceBuilderPromise {
    optionalArguments = Object.assign(new WithMultipleDefaultsArgs1(), optionalArguments);
    return new TestDatabaseResourceBuilderPromise(this._withMultipleDefaultsInternal(optionalArguments));
  }
}

/**
 * Thenable wrapper for TestRedisResourceBuilder that enables fluent chaining.
 * Usage: await builder.addX("name").withY().withZ();
 */
export class TestRedisResourceBuilderPromise implements PromiseLike<TestRedisResourceBuilder> {
  constructor(private _promise: Promise<TestRedisResourceBuilder>) {}

  then<TResult1 = TestRedisResourceBuilder, TResult2 = never>(
    onfulfilled?: ((value: TestRedisResourceBuilder) => TResult1 | PromiseLike<TResult1>) | null,
    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null
  ): PromiseLike<TResult1 | TResult2> {
    return this._promise.then(onfulfilled, onrejected);
  }

  /**
   * WithPersistence (fluent chaining)
   */
  withPersistence(mode?: TestPersistenceMode): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(
      this._promise.then(b => b._withPersistenceInternal(mode))
    );
  }

  /**
   * WithBuilderCallback (fluent chaining)
   */
  withBuilderCallback(configure?: (p0: TestRedisResourceBuilder) => void | Promise<void>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(
      this._promise.then(b => b._withBuilderCallbackInternal(configure))
    );
  }

  /**
   * WithCustomCallback (fluent chaining)
   */
  withCustomCallback(callback: (p0: TestCallbackContextProxy) => void | Promise<void>): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(
      this._promise.then(b => b._withCustomCallbackInternal(callback))
    );
  }

  /**
   * WithOptionalString (fluent chaining)
   */
  withOptionalString(optionalArguments?: WithOptionalStringArgs): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(
      this._promise.then(b => b._withOptionalStringInternal(optionalArguments))
    );
  }

  /**
   * WithMultipleDefaults (fluent chaining)
   */
  withMultipleDefaults(optionalArguments?: WithMultipleDefaultsArgs): TestRedisResourceBuilderPromise {
    return new TestRedisResourceBuilderPromise(
      this._promise.then(b => b._withMultipleDefaultsInternal(optionalArguments))
    );
  }
}

/**
 * Thenable wrapper for TestDatabaseResourceBuilder that enables fluent chaining.
 * Usage: await builder.addX("name").withY().withZ();
 */
export class TestDatabaseResourceBuilderPromise implements PromiseLike<TestDatabaseResourceBuilder> {
  constructor(private _promise: Promise<TestDatabaseResourceBuilder>) {}

  then<TResult1 = TestDatabaseResourceBuilder, TResult2 = never>(
    onfulfilled?: ((value: TestDatabaseResourceBuilder) => TResult1 | PromiseLike<TResult1>) | null,
    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null
  ): PromiseLike<TResult1 | TResult2> {
    return this._promise.then(onfulfilled, onrejected);
  }

  /**
   * WithCustomCallback (fluent chaining)
   */
  withCustomCallback(callback: (p0: TestCallbackContextProxy) => void | Promise<void>): TestDatabaseResourceBuilderPromise {
    return new TestDatabaseResourceBuilderPromise(
      this._promise.then(b => b._withCustomCallbackInternal(callback))
    );
  }

  /**
   * WithOptionalString (fluent chaining)
   */
  withOptionalString(optionalArguments?: WithOptionalStringArgs): TestDatabaseResourceBuilderPromise {
    return new TestDatabaseResourceBuilderPromise(
      this._promise.then(b => b._withOptionalStringInternal(optionalArguments))
    );
  }

  /**
   * WithMultipleDefaults (fluent chaining)
   */
  withMultipleDefaults(optionalArguments?: WithMultipleDefaultsArgs): TestDatabaseResourceBuilderPromise {
    return new TestDatabaseResourceBuilderPromise(
      this._promise.then(b => b._withMultipleDefaultsInternal(optionalArguments))
    );
  }
}

export enum TestPersistenceMode {
  None = "None", Volume = "Volume", Bind = "Bind"
}
export class WithOptionalStringArgs {
      public value?: string;
      public enabled?: boolean;

    constructor(args: Partial<WithOptionalStringArgs> = {}) {
      this.enabled  = true;
      Object.assign(this, args);
    }
}
export class WithMultipleDefaultsArgs {
      public count?: number;
      public prefix?: string;
      public useUpperCase?: boolean;
      public multiplier?: number;

    constructor(args: Partial<WithMultipleDefaultsArgs> = {}) {
      this.count  = 10;
      this.prefix  = "item";
      this.useUpperCase  = false;
      this.multiplier  = 1.5;
      Object.assign(this, args);
    }
}
export class WithOptionalStringArgs1 {
      public value?: string;
      public enabled?: boolean;

    constructor(args: Partial<WithOptionalStringArgs1> = {}) {
      this.enabled  = true;
      Object.assign(this, args);
    }
}
export class WithMultipleDefaultsArgs1 {
      public count?: number;
      public prefix?: string;
      public useUpperCase?: boolean;
      public multiplier?: number;

    constructor(args: Partial<WithMultipleDefaultsArgs1> = {}) {
      this.count  = 10;
      this.prefix  = "item";
      this.useUpperCase  = false;
      this.multiplier  = 1.5;
      Object.assign(this, args);
    }
}

/**
 * Typed proxy wrapper for TestCallbackContext
 * Provides typed access to .NET object properties via JSON-RPC
 */
export class TestCallbackContextProxy {
    constructor(private _proxy: DotNetProxy) {}

    /** Get the underlying proxy for advanced operations */
    get proxy(): DotNetProxy { return this._proxy; }

    /** The .NET type name */
    get $type(): string { return this._proxy.$type; }

    /** The object identifier for use in method calls */
    get $id(): string { return this._proxy.$id; }

    /**
     * Gets the Name property
     * @returns Promise<string>
     */
    async getName(): Promise<string> {
        const result = await this._proxy.getProperty("Name");
        return result as string;
    }

    /**
     * Sets the Name property
     */
    async setName(value: string): Promise<void> {
        await this._proxy.setProperty("Name", value);
    }

    /**
     * Gets the Value property
     * @returns Promise<number>
     */
    async getValue(): Promise<number> {
        const result = await this._proxy.getProperty("Value");
        return result as number;
    }

    /**
     * Sets the Value property
     */
    async setValue(value: number): Promise<void> {
        await this._proxy.setProperty("Value", value);
    }

    /**
     * Gets a property value from the .NET object (generic fallback)
     * @param propertyName The property name
     */
    async getProperty<T = unknown>(propertyName: string): Promise<T> {
        const result = await this._proxy.getProperty(propertyName);
        return result as T;
    }

    /**
     * Sets a property value on the .NET object (generic fallback)
     * @param propertyName The property name
     * @param value The value to set
     */
    async setProperty(propertyName: string, value: unknown): Promise<void> {
        await this._proxy.setProperty(propertyName, value);
    }

    /**
     * Gets an indexed value (e.g., dictionary[key])
     */
    async getIndexer<T = unknown>(key: string | number): Promise<T> {
        const result = await this._proxy.getIndexer(key);
        return result as T;
    }

    /**
     * Sets an indexed value (e.g., dictionary[key] = value)
     */
    async setIndexer(key: string | number, value: unknown): Promise<void> {
        await this._proxy.setIndexer(key, value);
    }

    /**
     * Invokes a method on the .NET object
     */
    async invokeMethod<T = unknown>(methodName: string, args?: Record<string, unknown>): Promise<T> {
        const result = await this._proxy.invokeMethod(methodName, args);
        return result as T;
    }

    /**
     * Releases the proxy reference
     */
    async dispose(): Promise<void> {
        await this._proxy.dispose();
    }
}

/**
 * Generic dictionary proxy for IDictionary<string, object> access
 */
export class DictionaryProxy {
    constructor(private _proxy: DotNetProxy) {}

    /** Get the underlying proxy for advanced operations */
    get proxy(): DotNetProxy { return this._proxy; }

    async get<T = unknown>(key: string): Promise<T> {
        const result = await this._proxy.getIndexer(key);
        return result as T;
    }

    async set(key: string, value: unknown): Promise<void> {
        await this._proxy.setIndexer(key, value);
    }

    async dispose(): Promise<void> {
        await this._proxy.dispose();
    }
}
,
  RemoteAppHostClient.ts:
// RemoteAppHostClient.ts - Connects to the GenericAppHost via socket/named pipe
import * as net from 'net';
import * as rpc from 'vscode-jsonrpc/node.js';
import { CallbackFunction, MarshalledObject } from './types.js';

// Callback registry - maps callback IDs to functions
const callbackRegistry = new Map<string, CallbackFunction>();
let callbackIdCounter = 0;

// Global reference to the client for proxy objects
let globalClient: RemoteAppHostClient | null = null;

/**
 * Register a callback function that can be invoked from the .NET side.
 * Returns a callback ID that should be passed to methods accepting callbacks.
 */
export function registerCallback<TArgs = unknown, TResult = void>(
    callback: (args: TArgs) => TResult | Promise<TResult>
): string {
    const callbackId = `callback_${++callbackIdCounter}_${Date.now()}`;
    callbackRegistry.set(callbackId, callback as CallbackFunction);
    return callbackId;
}

/**
 * Unregister a callback by its ID.
 */
export function unregisterCallback(callbackId: string): boolean {
    return callbackRegistry.delete(callbackId);
}

/**
 * Get the number of registered callbacks.
 */
export function getCallbackCount(): number {
    return callbackRegistry.size;
}

/**
 * A proxy object that represents a .NET object.
 * Allows calling methods and accessing properties on the remote object.
 */
export class DotNetProxy {
    private readonly _id: string;
    private readonly _type: string;
    private readonly _data: Record<string, unknown>;

    constructor(marshalled: MarshalledObject) {
        this._id = marshalled.$id;
        this._type = marshalled.$type;
        this._data = { ...marshalled };
    }

    /** The object ID in the .NET object registry */
    get $id(): string {
        return this._id;
    }

    /** The .NET type name */
    get $type(): string {
        return this._type;
    }

    /** Get a cached property value (may be stale) */
    getCachedValue(propertyName: string): unknown {
        return this._data[propertyName];
    }

    /** Serialize for JSON-RPC transport - includes $id so .NET can resolve the reference */
    toJSON() {
        return {
            $id: this._id,
            $type: this._type
        };
    }

    /** Invoke a method on the .NET object */
    async invokeMethod(methodName: string, args?: Record<string, unknown>): Promise<unknown> {
        if (!globalClient) {
            throw new Error('No connection to .NET host');
        }
        const result = await globalClient.invokeMethod(this._id, methodName, args);
        return wrapIfProxy(result);
    }

    /** Get a property value from the .NET object (fetches fresh value) */
    async getProperty(propertyName: string): Promise<unknown> {
        if (!globalClient) {
            throw new Error('No connection to .NET host');
        }
        const result = await globalClient.getProperty(this._id, propertyName);
        return wrapIfProxy(result);
    }

    /** Set a property value on the .NET object */
    async setProperty(propertyName: string, value: unknown): Promise<void> {
        if (!globalClient) {
            throw new Error('No connection to .NET host');
        }
        await globalClient.setProperty(this._id, propertyName, value);
    }

    /** Get an indexed value (e.g., dictionary[key]) */
    async getIndexer(key: string | number): Promise<unknown> {
        if (!globalClient) {
            throw new Error('No connection to .NET host');
        }
        const result = await globalClient.getIndexer(this._id, key);
        return wrapIfProxy(result);
    }

    /** Set an indexed value (e.g., dictionary[key] = value) */
    async setIndexer(key: string | number, value: unknown): Promise<void> {
        if (!globalClient) {
            throw new Error('No connection to .NET host');
        }
        await globalClient.setIndexer(this._id, key, value);
    }

    /** Release this object from the .NET registry */
    async dispose(): Promise<void> {
        if (!globalClient) {
            return;
        }
        await globalClient.unregisterObject(this._id);
    }
}

/**
 * A proxy for .NET List<T> or IList<T> collections.
 * Provides list-like operations: add, get, count, clear, etc.
 */
export class ListProxy<T = unknown> {
    constructor(private _proxy: DotNetProxy) {}

    /** Get the underlying proxy for advanced operations */
    get proxy(): DotNetProxy { return this._proxy; }

    /**
     * Add an item to the list
     */
    async add(item: T): Promise<void> {
        const args = { item };
        console.log(`ListProxy.add: calling Add with args =`, JSON.stringify(args));
        await this._proxy.invokeMethod('Add', args);
    }

    /**
     * Get an item by index
     */
    async get(index: number): Promise<T> {
        const result = await this._proxy.getIndexer(index);
        return result as T;
    }

    /**
     * Set an item at the specified index
     */
    async set(index: number, value: T): Promise<void> {
        await this._proxy.setIndexer(index, value);
    }

    /**
     * Get the number of items in the list
     */
    async count(): Promise<number> {
        const result = await this._proxy.getProperty('Count');
        return result as number;
    }

    /**
     * Remove all items from the list
     */
    async clear(): Promise<void> {
        await this._proxy.invokeMethod('Clear');
    }

    /**
     * Check if the list contains an item
     */
    async contains(item: T): Promise<boolean> {
        const result = await this._proxy.invokeMethod('Contains', { item });
        return result as boolean;
    }

    /**
     * Remove an item from the list
     */
    async remove(item: T): Promise<boolean> {
        const result = await this._proxy.invokeMethod('Remove', { item });
        return result as boolean;
    }

    /**
     * Remove an item at the specified index
     */
    async removeAt(index: number): Promise<void> {
        await this._proxy.invokeMethod('RemoveAt', { index });
    }

    /**
     * Insert an item at the specified index
     */
    async insert(index: number, item: T): Promise<void> {
        await this._proxy.invokeMethod('Insert', { index, item });
    }

    /**
     * Release the proxy reference
     */
    async dispose(): Promise<void> {
        await this._proxy.dispose();
    }
}

/**
 * Represents a ReferenceExpression that can be passed to .NET methods.
 * This is the result of using the `refExpr` tagged template literal.
 *
 * Serializes as a format string with {$id} placeholders for object references,
 * which .NET can easily reconstruct using ReferenceExpressionBuilder.
 */
export class ReferenceExpression {
    /** Marker to identify this as a ReferenceExpression for serialization */
    readonly $referenceExpression = true;

    constructor(
        /** The format string with {$id} placeholders */
        public readonly format: string
    ) {}

    /**
     * Converts to a serializable format for passing to .NET.
     */
    toJSON() {
        return {
            $referenceExpression: true,
            format: this.format
        };
    }
}

/**
 * Interface for proxy wrapper classes that have an underlying DotNetProxy.
 */
export interface HasProxy {
    proxy: DotNetProxy;
}

/**
 * Type guard to check if a value has a proxy property.
 */
function hasProxy(value: unknown): value is HasProxy {
    return value !== null && typeof value === 'object' && 'proxy' in value && (value as HasProxy).proxy instanceof DotNetProxy;
}

/**
 * Tagged template literal for creating ReferenceExpression instances.
 *
 * DotNetProxy values (or proxy wrappers) are replaced with {$id} placeholders
 * that .NET uses to look up objects from the registry.
 *
 * Usage:
 * ```typescript
 * const endpoint = await redis.getEndpoint("tcp");
 * const password = await builder.addParameter("password", { secret: true });
 * const expr = refExpr`Host=${endpoint};Password=${password}`;
 * await resource.withEnvironment("CONNECTION_STRING", expr);
 * ```
 */
export function refExpr(strings: TemplateStringsArray, ...values: (DotNetProxy | HasProxy | string | number | boolean)[]): ReferenceExpression {
    let format = '';

    for (let i = 0; i < strings.length; i++) {
        format += strings[i];

        if (i < values.length) {
            const value = values[i];
            if (value instanceof DotNetProxy) {
                // Use the object's $id as a placeholder
                format += `{${value.$id}}`;
            } else if (hasProxy(value)) {
                // Proxy wrapper - use the underlying proxy's $id
                format += `{${value.proxy.$id}}`;
            } else {
                // Primitives are inlined as literals
                format += String(value);
            }
        }
    }

    return new ReferenceExpression(format);
}

/**
 * Checks if a value is a marshalled .NET object and wraps it in a proxy if so.
 */
export function wrapIfProxy(value: unknown): unknown {
    if (value && typeof value === 'object' && '$id' in value && '$type' in value) {
        return new DotNetProxy(value as MarshalledObject);
    }
    return value;
}

/**
 * Creates a proxy from a marshalled object received from .NET.
 */
export function createProxy(marshalled: MarshalledObject): DotNetProxy {
    return new DotNetProxy(marshalled);
}

export class RemoteAppHostClient {
    private connection: rpc.MessageConnection | null = null;
    private socket: net.Socket | null = null;
    private disconnectCallbacks: (() => void)[] = [];

    constructor(private socketPath: string) { }

    /**
     * Register a callback to be called when the connection is lost
     */
    onDisconnect(callback: () => void): void {
        this.disconnectCallbacks.push(callback);
    }

    private notifyDisconnect(): void {
        for (const callback of this.disconnectCallbacks) {
            try {
                callback();
            } catch {
                // Ignore callback errors
            }
        }
    }

    connect(timeoutMs: number = 5000): Promise<void> {
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => reject(new Error('Connection timeout')), timeoutMs);

            // On Windows, socket path is a named pipe; on Unix, it's a Unix domain socket path
            const isWindows = process.platform === 'win32';
            const pipePath = isWindows ? `\\\\.\\pipe\\${this.socketPath}` : this.socketPath;

            this.socket = net.createConnection(pipePath);

            this.socket.once('error', (error: Error) => {
                clearTimeout(timeout);
                reject(error);
            });

            this.socket.once('connect', () => {
                clearTimeout(timeout);
                try {
                    const reader = new rpc.SocketMessageReader(this.socket!);
                    const writer = new rpc.SocketMessageWriter(this.socket!);
                    this.connection = rpc.createMessageConnection(reader, writer);

                    this.connection.onClose(() => {
                        this.connection = null;
                        this.notifyDisconnect();
                    });
                    this.connection.onError((err: any) => console.error('JsonRpc connection error:', err));

                    // Handle callback invocations from the .NET side
                    this.connection.onRequest('invokeCallback', async (callbackId: string, args: unknown) => {
                        const callback = callbackRegistry.get(callbackId);
                        if (!callback) {
                            throw new Error(`Callback not found: ${callbackId}`);
                        }
                        try {
                            // Wrap marshalled objects in proxies
                            const wrappedArgs = wrapIfProxy(args);
                            // Always await in case the callback is async
                            return await Promise.resolve(callback(wrappedArgs));
                        } catch (error) {
                            const message = error instanceof Error ? error.message : String(error);
                            throw new Error(`Callback execution failed: ${message}`);
                        }
                    });

                    this.connection.listen();

                    // Set global client reference for proxy objects
                    globalClient = this;

                    resolve();
                } catch (e) {
                    reject(e);
                }
            });

            this.socket.on('close', () => {
                this.connection?.dispose();
                this.connection = null;
                this.notifyDisconnect();
            });
        });
    }

    ping(): Promise<string> {
        if (!this.connection) return Promise.reject(new Error('Not connected to RemoteAppHost'));
        return this.connection.sendRequest('ping');
    }

    /** Invoke a method on a .NET object (instance methods only) */
    invokeMethod(objectId: string, methodName: string, args?: Record<string, unknown>): Promise<unknown> {
        if (!this.connection) return Promise.reject(new Error('Not connected to RemoteAppHost'));
        return this.connection.sendRequest('invokeMethod', objectId, methodName, args ?? null);
    }

    /** Invoke a static method on a .NET type */
    invokeStaticMethod(assemblyName: string, typeName: string, methodName: string, args?: Record<string, unknown>): Promise<unknown> {
        if (!this.connection) return Promise.reject(new Error('Not connected to RemoteAppHost'));
        return this.connection.sendRequest('invokeStaticMethod', assemblyName, typeName, methodName, args ?? null);
    }

    /** Create an instance of a .NET type */
    createObject(assemblyName: string, typeName: string, args?: Record<string, unknown>): Promise<unknown> {
        if (!this.connection) return Promise.reject(new Error('Not connected to RemoteAppHost'));
        return this.connection.sendRequest('createObject', assemblyName, typeName, args ?? null);
    }

    /** Get a property from a .NET object */
    getProperty(objectId: string, propertyName: string): Promise<unknown> {
        if (!this.connection) return Promise.reject(new Error('Not connected to RemoteAppHost'));
        return this.connection.sendRequest('getProperty', objectId, propertyName);
    }

    /** Set a property on a .NET object */
    setProperty(objectId: string, propertyName: string, value: unknown): Promise<void> {
        if (!this.connection) return Promise.reject(new Error('Not connected to RemoteAppHost'));
        return this.connection.sendRequest('setProperty', objectId, propertyName, value);
    }

    /** Get an indexed value from a .NET object */
    getIndexer(objectId: string, key: string | number): Promise<unknown> {
        if (!this.connection) return Promise.reject(new Error('Not connected to RemoteAppHost'));
        return this.connection.sendRequest('getIndexer', objectId, key);
    }

    /** Set an indexed value on a .NET object */
    setIndexer(objectId: string, key: string | number, value: unknown): Promise<void> {
        if (!this.connection) return Promise.reject(new Error('Not connected to RemoteAppHost'));
        return this.connection.sendRequest('setIndexer', objectId, key, value);
    }

    /** Unregister an object from the .NET registry */
    unregisterObject(objectId: string): Promise<void> {
        if (!this.connection) return Promise.reject(new Error('Not connected to RemoteAppHost'));
        return this.connection.sendRequest('unregisterObject', objectId);
    }

    /** Get a static property from a .NET type */
    getStaticProperty(assemblyName: string, typeName: string, propertyName: string): Promise<unknown> {
        if (!this.connection) return Promise.reject(new Error('Not connected to RemoteAppHost'));
        return this.connection.sendRequest('getStaticProperty', assemblyName, typeName, propertyName);
    }

    /** Set a static property on a .NET type */
    setStaticProperty(assemblyName: string, typeName: string, propertyName: string, value: unknown): Promise<void> {
        if (!this.connection) return Promise.reject(new Error('Not connected to RemoteAppHost'));
        return this.connection.sendRequest('setStaticProperty', assemblyName, typeName, propertyName, value);
    }

    disconnect(): void {
        globalClient = null;
        try { this.connection?.dispose(); } finally { this.connection = null; }
        try { this.socket?.end(); } finally { this.socket = null; }
    }

    get connected(): boolean {
        return this.connection !== null && this.socket !== null;
    }
}
,
  types.ts:
/**
 * Type for callback functions that can be registered and invoked from .NET.
 */
export type CallbackFunction = (args: unknown) => unknown | Promise<unknown>;

/**
 * Represents a marshalled .NET object received over JSON-RPC.
 * Contains the object ID for RPC calls and metadata about the object.
 */
export interface MarshalledObject {
    /** The object ID in the .NET object registry */
    $id: string;
    /** The .NET type name */
    $type: string;
    /** The full .NET type name including namespace */
    $fullType?: string;
    /** Available methods on the object */
    $methods?: Array<{
        name: string;
        parameters: Array<{ name: string; type: string }>;
    }>;
    /** Additional properties with their values (simple types) or type info (complex types) */
    [key: string]: unknown;
}

}