<Project>
  <PropertyGroup>
    <GetWorkloadInputsDependsOn>_GetWorkloadsToInstall;$(GetWorkloadInputsDependsOn)</GetWorkloadInputsDependsOn>
    <GetNuGetsToBuildForWorkloadTestingDependsOn>_ValidateExpectedSetOfPackagesExist;_GetNuGetsToBuild;$(GetNuGetsToBuildForWorkloadTestingDependsOn)</GetNuGetsToBuildForWorkloadTestingDependsOn>

    <!-- this will cause the output for `dotnet workload install` to be visible to the user -->
    <WorkloadInstallCommandOutputImportance>High</WorkloadInstallCommandOutputImportance>
    <NuGetConfigPackageSourceMappingsForWorkloadTesting>*Aspire*</NuGetConfigPackageSourceMappingsForWorkloadTesting>

    <_ShippingPackagesDir>$([MSBuild]::NormalizeDirectory($(ArtifactsDir), 'packages', $(Configuration), 'Shipping'))</_ShippingPackagesDir>

    <_GlobalJsonContent>$([System.IO.File]::ReadAllText('$(RepoRoot)global.json'))</_GlobalJsonContent>
    <_DotNetCliVersionFromGlobalJson>$([System.Text.RegularExpressions.Regex]::Match($(_GlobalJsonContent), '(%3F&lt;="dotnet": ").*(%3F=")'))</_DotNetCliVersionFromGlobalJson>
    <SdkVersionForWorkloadTesting Condition="'$(SdkVersionForWorkloadTesting)' == ''">$(_DotNetCliVersionFromGlobalJson)</SdkVersionForWorkloadTesting>

    <VersionBandForSdkManifestsDir>$(DotNetVersionBand)</VersionBandForSdkManifestsDir>
    <VersionBandForManifestPackages>$(DotNetVersionBand)</VersionBandForManifestPackages>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.NET.Runtime.WorkloadTesting.Internal" />
  </ItemGroup>

  <Target Name="_GetNuGetsToBuild" Returns="@(NuGetsToBuildForWorkloadTesting)">
    <Error Condition="'$(VersionBandForManifestPackages)' == '' or '$(VersionBandForManifestPackages)' == ''"
           Text="Both properties need to be set: %24(VersionBandForSdkManifestsDir)=$(VersionBandForSdkManifestsDir), and %24(VersionBandForManifestPackages)=$(VersionBandForManifestPackages)" />

    <ItemGroup>
      <_ManifestPackage Include="$(_ShippingPackagesDir)Microsoft.NET.Sdk.Aspire.Manifest*nupkg" />
    </ItemGroup>
    <Error Condition="@(_ManifestPackage->Count()) == 0" Text="No manifest packages found in $(_ShippingPackagesDir). Make sure build packages with './build.sh -pack'" />

    <Error Condition="'$(NETCoreSdkRuntimeIdentifier)' == ''" Text="%24(NETCoreSdkRuntimeIdentifier) is unset. This is needed to build the Aspire.Hosting.Orchestration nuget" />

    <ItemGroup>
      <_PropertiesForNuGetBuilds Include="DashboardRuntime=$(NETCoreSdkRuntimeIdentifier)" />
      <_PropertiesForNuGetBuilds Include="DcpRuntime=$(NETCoreSdkRuntimeIdentifier)" />
      <_PropertiesForNuGetBuilds Include="PackageOutputPath=$(WorkloadsPackageSource)" />

      <NuGetsToBuildForWorkloadTesting
                      Include="$(_ShippingPackagesDir)Aspire.Dashboard.Sdk.$(NETCoreSdkRuntimeIdentifier).nupkg"
                      Project="$(RepoRoot)eng/dashboardpack/dashboardpack.csproj"
                      Properties="@(DefaultPropertiesForNuGetBuild, ';');@(_PropertiesForNuGetBuilds, ';')"
                      Descriptor="Dashboard pack"/>

      <NuGetsToBuildForWorkloadTesting
                      Include="$(_ShippingPackagesDir)Aspire.Hosting.Orchestration.$(NETCoreSdkRuntimeIdentifier).nupkg"
                      Project="$(RepoRoot)eng/dcppack/dcppack.csproj"
                      Properties="@(DefaultPropertiesForNuGetBuild, ';');@(_PropertiesForNuGetBuilds, ';')"
                      Descriptor="Dcp pack"/>
    </ItemGroup>

    <PropertyGroup>
      <_CombinedProps>@(DefaultPropertiesForNuGetBuild, ';');@(_PropertiesForNuGetBuilds, ';')</_CombinedProps>
    </PropertyGroup>
    <!-- FIXME:
      Explicitly invoke Build on these two projects so the GenerateTextReplacementFiles target gets triggered.
      This can be removed once the workloadtesting targets support a custom list of targets to invoke
    -->
    <MSBuild Projects="$(RepoRoot)eng/dcppack/dcppack.csproj"
              Properties="$(_CombinedProps)"
              Targets="Restore;Build" />
    <MSBuild Projects="$(RepoRoot)eng/dashboardpack/dashboardpack.csproj"
              Properties="$(_CombinedProps)"
              Targets="Restore;Build" />
  </Target>

  <Target Name="_GetWorkloadsToInstall" DependsOnTargets="_SetPackageVersionForWorkloadsTesting" Returns="@(WorkloadIdForTesting);@(WorkloadCombinationsToInstall)">
    <ItemGroup>
      <WorkloadIdForTesting Include="aspire"
                            ManifestName="Microsoft.NET.Sdk.Aspire"
                            Variant="latest"
                            Version="$(PackageVersionForWorkloadManifests)" />

      <WorkloadCombinationsToInstall Include="latest" Variants="latest" />
    </ItemGroup>
  </Target>

  <!-- generate before the build so the project can use this in a <None ..> item -->
  <Target Name="_GeneratePackagesVersionsProps" BeforeTargets="BeforeBuild" Condition="'$(ArchiveTests)' == 'true' or '$(TestsRunningOutsideOfRepo)' == 'true'">
    <!-- Duplicate all the @(PackageVersion) items with the evaluated versions -->
    <ItemGroup>
      <_PackageVersionEvaluated Include="@(PackageVersion -> '&lt;PackageVersion Include=&quot;%(Identity)&quot; Version=&quot;%(Version)&quot; /&gt;')" />

      <!-- Emit all properties named in @(PropertyForHelixRun).
           doing this separately so the property value can be extracted from the name -->
      <_PropertiesToPass
        Include="$(%(PropertyForHelixRun.Identity))"
        Name="%(PropertyForHelixRun.Identity)"
        ConditionToUse__="%(PropertyForHelixRun.ConditionToUse__)" />
      <_PropertiesToPassEvaluated Include="@(_PropertiesToPass -> '&lt;%(Name)&gt;%(Identity)&lt;/%(Name)&gt;')" />
    </ItemGroup>
    <PropertyGroup>
      <_HelixPropsContent>
        <![CDATA[
      <Project>
        <PropertyGroup>
          <PackageVersion>$(PackageVersion)</PackageVersion>

          <ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally>
        </PropertyGroup>

        <ItemGroup>
            @(_PackageVersionEvaluated, '
            ')
        </ItemGroup>

        <PropertyGroup Label="From PropertyForHelixRun">
            @(_PropertiesToPassEvaluated, '
            ')
        </PropertyGroup>
      </Project>
          ]]>
      </_HelixPropsContent>
    </PropertyGroup>

    <WriteLinesToFile Lines="$(_HelixPropsContent)" File="$(GeneratedPackagesVersionsPropsPath)" Overwrite="true" />
  </Target>

  <!--<UsingTask TaskName="PrepareNuGetConfigForWorkloadTesting"-->
      <!--TaskFactory="RoslynCodeTaskFactory"-->
      <!--AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">-->
    <!--<ParameterGroup>-->
      <!--<TemplateNuGetConfigPath ParameterType="System.String" Required="true" />-->
      <!--<OutputFile ParameterType="System.String" Required="true" />-->
    <!--</ParameterGroup>-->
    <!--<Task>-->
      <!--<Using Namespace="System.IO" />-->
      <!--<Using Namespace="System.Xml.Linq" />-->
      <!--<Using Namespace="System.Xml.XPath" />-->
      <!--<Code Type="Fragment" Language="cs">-->
        <!--<![CDATA[-->
          <!--if (!File.Exists(TemplateNuGetConfigPath))-->
          <!--{-->
            <!--Log.LogError($"Could not find nuget config template at '{TemplateNuGetConfigPath}' .");-->
            <!--return false;-->
          <!--}-->

          <!--// This task adds a nuget packageSource pointing to the locally built nugets.-->
          <!--// And then adds a packageSourceMapping for that source to `*Aspire*` so the-->
          <!--// locally built nugets can be restored from there-->

          <!--// add packageSource-->
          <!--XDocument doc = XDocument.Load(TemplateNuGetConfigPath);-->
          <!--string xpath = "/configuration/packageSources";-->
          <!--XElement packageSources = doc.XPathSelectElement(xpath);-->
          <!--if (packageSources is null)-->
          <!--{-->
            <!--Log.LogError($"Could not find {xpath} in {TemplateNuGetConfigPath}");-->
            <!--return false;-->
          <!--}-->

          <!--// %BUILT_NUGETS_PATH% is set when building the testproject-->
          <!--packageSources.LastNode.AddAfterSelf(-->
            <!--new XElement("add",-->
              <!--new XAttribute("key", "nuget-local"),-->
              <!--new XAttribute("value", "%BUILT_NUGETS_PATH%")));-->

          <!--// add packageSourceMapping-->
          <!--string mappingXpath = "/configuration/packageSourceMapping";-->
          <!--XElement packageSourceMapping = doc.XPathSelectElement(mappingXpath);-->
          <!--if (packageSourceMapping is null)-->
          <!--{-->
            <!--// if mapping has been removed completely then the task needs an update!-->
            <!--throw new InvalidOperationException($"Expected to find {mappingXpath} in {TemplateNuGetConfigPath}");-->
          <!--}-->

          <!--packageSourceMapping.FirstNode.AddBeforeSelf(-->
            <!--new XElement("packageSource",-->
              <!--new XAttribute("key", "nuget-local"),-->
              <!--new XElement("package", new XAttribute("pattern", "*Aspire*"))));-->

          <!--doc.Save(OutputFile);-->
          <!--Log.LogMessage(MessageImportance.Low, $"Generated patched nuget.config at {OutputFile}");-->
        <!--]]>-->
      <!--</Code>-->
    <!--</Task>-->
  <!--</UsingTask>-->

  <!-- For test projects -->

  <!--<Target Name="_PatchNuGetConfig" AfterTargets="GetCopyToOutputDirectoryItems" Inputs="$(TemplateNuGetConfigPath)" Outputs="$(PatchedNuGetConfigPath)">-->
    <!--<PrepareNuGetConfigForWorkloadTesting TemplateNuGetConfigPath="$(RepoRoot)NuGet.config" OutputFile="$(PatchedNuGetConfigPath)" />-->
  <!--</Target>-->

  <Target Name="CheckForWorkloadInstalled" BeforeTargets="VSTest" Condition="'$(TestsRunningOutsideOfRepo)' == 'true'">
    <Error Condition="'$(SdkWithWorkloadForTestingPath)' == '' or !Exists($(SdkWithWorkloadForTestingPath))"
      Text="Could not find %24(SdkWithWorkloadForTestingPath)=$(SdkWithWorkloadForTestingPath) . Prepare it by following:
      1. .\build.cmd -pack (or ./build.sh on unix)
      2. dotnet build tests/workloads.proj /p:Configuration=$(Configuration)" />
  </Target>

  <Target Name="_ValidateExpectedSetOfPackagesExist" Condition="'$(SkipPackageCheckForWorkloadTesting)' != 'true'">
    <ItemGroup>
      <_SrcProjects Include="$(RepoRoot)src\**\*.csproj" Exclude="$(RepoRoot)src\Aspire.ProjectTemplates\templates\**" />
    </ItemGroup>

    <MSBuild Projects="@(_SrcProjects)" Targets="GetPackageName">
      <Output TaskParameter="TargetOutputs" ItemName="_PackableProjectName" />
    </MSBuild>
    <ItemGroup>
      <!-- Ignore Microsoft.NET.Sdk.Aspire as the emitted package name is special: Microsoft.NET.Sdk.Aspire.Manifest-$(sdkband)-* -->
      <ExpectedPackageNames
          Include="@(_PackableProjectName)"
          Condition="'%(Identity)' != '' and '%(Identity)' != 'Microsoft.NET.Sdk.Aspire'" />
    </ItemGroup>

    <!-- check against an arbitrary minimum limit to catch any issues getting the list of packages -->
    <Error Text="Too few packages? count: @(ExpectedPackageNames->Count())"
           Condition="@(ExpectedPackageNames->Count()) &lt; 60"
           Importance="High" />

    <ItemGroup>
      <AllPackages Include="$(ArtifactsShippingPackagesDir)*.nupkg" />
      <ExpectedPackagePaths Include="$(ArtifactsShippingPackagesDir)%(ExpectedPackageNames.Identity).$(PackageVersion).nupkg" />
      <MissingPackages Include="@(ExpectedPackagePaths)" Condition="!Exists(%(ExpectedPackagePaths.Identity))" />

      <UnexpectedPackages Include="@(AllPackages)" Exclude="@(ExpectedPackagePaths)" />

      <!-- Ignore these packages which are part of the workload. Existence of these would get checked
            by the workload installation targets. And their names don't correspond to project names. -->
      <UnexpectedPackages Remove="@(UnexpectedPackages)" Condition="$([System.String]::Copy('%(UnexpectedPackages.FileName)').StartsWith('Microsoft.NET.Sdk.Aspire.Manifest-'))" />
      <UnexpectedPackages Remove="@(UnexpectedPackages)" Condition="$([System.String]::Copy('%(UnexpectedPackages.FileName)').StartsWith('Aspire.Hosting.Orchestration.'))" />
      <UnexpectedPackages Remove="@(UnexpectedPackages)" Condition="$([System.String]::Copy('%(UnexpectedPackages.FileName)').StartsWith('Aspire.Dashboard.Sdk.'))" />
    </ItemGroup>

    <Warning Text="Found some unexpected packages in '$(ArtifactsShippingPackagesDir)', which might mean that the list of expected packages is incorrect: @(UnexpectedPackages -> '%(FileName)%(Extension)', ', '). Use %24(SkipPackageCheckForWorkloadTesting)='true' to skip this."
             Condition="@(UnexpectedPackages -> Count()) &gt; 0" />
    <Error Text="Missing some expected packages in '$(ArtifactsShippingPackagesDir)': @(MissingPackages -> '%(FileName)%(Extension)',', ') . Make sure to build with `-pack`. Use %24(SkipPackageCheckForWorkloadTesting)='true' to skip this."
           Condition="@(MissingPackages -> Count()) &gt; 0" />
  </Target>

  <!-- Used for running one helix job per test class -->
  <Target Name="_ExtractTestClassNames"
          Condition="'$(ExtractTestClassNamesForHelix)' == 'true'"
          BeforeTargets="ZipTestArchive">

    <Error Condition="'$(ExtractTestClassNamesPrefix)' == ''"
           Text="%24(ExtractTestClassNamesPrefix) should be set, for example - Aspire.Workload.Tests" />

    <Exec Command="&quot;$(DotNetTool)&quot; test --no-build -c $(Configuration) -s $(RunSettingsFilePath) --list-tests --nologo -v:q -p:VsTestUseMSBuildOutput=false" ConsoleToMSBuild="true">
      <Output TaskParameter="ConsoleOutput" ItemName="_ListOfTestsLines" />
    </Exec>

    <PropertyGroup>
      <_Regex>^\s*($(ExtractTestClassNamesPrefix)[^\($]+)</_Regex>
    </PropertyGroup>
    <ItemGroup>
      <_TestLines0 Include="$([System.Text.RegularExpressions.Regex]::Match('%(_ListOfTestsLines.Identity)', '$(_Regex)'))" />
      <TestClassName Include="$([System.IO.Path]::GetFileNameWithoutExtension('%(_TestLines0.Identity)'))" />
    </ItemGroup>

    <Error Text="No $(ExtractTestClassNamesPrefix) test classes found!" Condition="'@(TestClassName)' == ''" />

    <WriteLinesToFile File="$(TestArchiveTestsDir)$(MSBuildProjectName).tests.list"
                      Lines="@(TestClassName->Distinct())"
                      Overwrite="true" />
  </Target>

</Project>
