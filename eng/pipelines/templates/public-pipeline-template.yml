parameters:
  - name: testVariants
    type: string
    default: ''

variables:
  - template: /eng/common/templates/variables/pool-providers.yml

  - name: _BuildConfig
    value: Release
  - name: Build.Arcade.ArtifactsPath
    value: $(Build.SourcesDirectory)/artifacts/
  - name: Build.Arcade.LogsPath
    value: $(Build.Arcade.ArtifactsPath)log/$(_BuildConfig)/
  - name: Build.Arcade.TestResultsPath
    value: $(Build.Arcade.ArtifactsPath)TestResults/$(_BuildConfig)/

  # needed for darc (dependency flow) publishing
  - name: _PublishArgs
    value: ''
  - name: _OfficialBuildIdArgs
    value: ''
  # needed for signing
  - name: _SignType
    value: test
  - name: _SignArgs
    value: ''
  - name: _Sign
    value: false
  - name: HelixApiAccessToken
    value: ''
  - name: _InternalBuildArgs
    value: ''

  # Set test variants based on parameter or build reason
  - ${{ if ne(parameters.testVariants, '') }}:
    - name: testVariants
      value: ${{ parameters.testVariants }}
  - ${{ else }}:
    # Use the build reason to decide whether to include helix_tests
    - ${{ if notin(variables['Build.Reason'], 'PullRequest') }}:
      - name: testVariants
        value: '_integration_matrix_tests'
    - ${{ else }}:
      - name: testVariants
        value: ''

resources:
  containers:
  - container: LinuxContainer
    image: mcr.microsoft.com/dotnet-buildtools/prereqs:cbl-mariner-2.0-fpm

stages:

# ----------------------------------------------------------------
# Helix-based stages (for non-matrix tests)
# ----------------------------------------------------------------
- ${{ if not(contains(variables.testVariants, '_integration_matrix_tests')) }}:
  - stage: build
    displayName: Build
    jobs:
    - template: /eng/common/templates/jobs/jobs.yml
      parameters:
        artifacts:
          publish:
            artifacts: false
            logs:
              name: 'Logs_Build_$(Agent.JobName)_$(_BuildConfig)'
            manifests: true
        enableMicrobuild: true
        enablePublishUsingPipelines: true
        publishAssetsImmediately: true
        enablePublishTestResults: true
        testResultsFormat: vstest
        enableSourceIndex: false
        workspace:
          clean: all

        jobs:

        # Helix jobs (Templates, EndToEnd - temporarily preserved)
        - ${{ each testVariant in split( variables.testVariants, ',' ) }}:
          - ${{ if contains(testVariant, '_helix') }}:
          - job: Windows${{ testVariant }}

            # timeout accounts for wait times for helix agents up to 30mins
            timeoutInMinutes: 90

            pool:
              name: $(DncEngPublicBuildPool)
              demands: ImageOverride -equals windows.vs2022preview.amd64.open

            variables:
              - name: _buildScript
                value: $(Build.SourcesDirectory)/build.cmd -ci

            preSteps:
              - checkout: self
                fetchDepth: 1
                clean: true

            steps:
              - template: /eng/pipelines/templates/BuildAndTest.yml
                parameters:
                  runAsPublic: true
                  dotnetScript: $(Build.SourcesDirectory)/dotnet.cmd
                  buildScript: $(_buildScript)
                  buildConfig: $(_BuildConfig)
                  repoArtifactsPath: $(Build.Arcade.ArtifactsPath)
                  repoLogPath: $(Build.Arcade.LogsPath)
                  repoTestResultsPath: $(Build.Arcade.TestResultsPath)
                  isWindows: true
                  runHelixTests: true
                  runPipelineTests: false

          - job: Linux${{ testVariant }}

            # timeout accounts for wait times for helix agents up to 30mins
            timeoutInMinutes: 90

            pool:
              name: $(DncEngPublicBuildPool)
              demands: ImageOverride -equals build.ubuntu.2204.amd64.open

            variables:
              - name: _buildScript
                value: $(Build.SourcesDirectory)/build.sh --ci

            preSteps:
              - checkout: self
                fetchDepth: 1
                clean: true

            steps:
              - template: /eng/pipelines/templates/BuildAndTest.yml
                parameters:
                  runAsPublic: true
                  dotnetScript: $(Build.SourcesDirectory)/dotnet.sh
                  buildScript: $(_buildScript)
                  buildConfig: $(_BuildConfig)
                  repoArtifactsPath: $(Build.Arcade.ArtifactsPath)
                  repoLogPath: $(Build.Arcade.LogsPath)
                  repoTestResultsPath: $(Build.Arcade.TestResultsPath)
                  isWindows: false
                  runHelixTests: true
                  runPipelineTests: false

# ----------------------------------------------------------------
# Setup Stages - Platform-specific .NET SDK setup and test enumeration
# ----------------------------------------------------------------
- ${{ if contains(variables.testVariants, '_integration_matrix_tests') }}:
  - stage: SetupLinux
    displayName: 'Setup Linux'
    jobs:
      - job: SetupDotNetLinux
        displayName: 'Setup .NET SDK - Linux'
        pool:
          name: $(DncEngPublicBuildPool)
          demands: ImageOverride -equals build.ubuntu.2204.amd64.open

        steps:
          - checkout: self
            fetchDepth: 1
            clean: true

          - pwsh: |
              ./restore.sh
            displayName: 'Restore .NET SDK'

          - task: PublishPipelineArtifact@1
            displayName: 'Publish .NET SDK - Linux'
            inputs:
              targetPath: '$(Build.SourcesDirectory)/.dotnet'
              artifactName: 'dotnet-sdk-linux'
              publishLocation: 'pipeline'

      - job: EnumerateIntegrationTests
        displayName: 'Enumerate Integration Tests'
        pool:
          name: $(DncEngPublicBuildPool)
          demands: ImageOverride -equals build.ubuntu.2204.amd64.open

        steps:
          - checkout: self
            fetchDepth: 1
            clean: true

          - pwsh: |
              ./restore.sh
            displayName: 'Restore .NET SDK'

          - pwsh: |
              ./dotnet.sh build tests/Shared/GetTestProjects.proj /bl:$(Build.Arcade.LogsPath)/GetTestProjects.binlog /p:TestsListOutputPath=$(Build.Arcade.ArtifactsPath)/IntegrationTests.list /p:ContinuousIntegrationBuild=true
            displayName: 'Generate integration tests list'

          - pwsh: |
              $testsListFile = "$(Build.Arcade.ArtifactsPath)/IntegrationTests.list"
              if (-not (Test-Path $testsListFile)) {
                throw "Tests list file not found: $testsListFile"
              }

              $testNames = Get-Content $testsListFile | Where-Object { $_.Trim() -ne "" } | Sort-Object
              if ($testNames.Count -eq 0) {
                throw "No integration tests found"
              }

              Write-Host "Found $($testNames.Count) integration test projects:"
              $testNames | ForEach-Object { Write-Host "  - $_" }

              # Create Linux matrix only
              $linuxMatrix = @{}
              $linuxPlatform = @{ name = 'Linux'; image = 'build.ubuntu.2204.amd64.open'; script = 'dotnet.sh' }

              foreach ($testName in $testNames) {
                $linuxKey = "$testName`_Linux"
                $linuxMatrix[$linuxKey] = @{
                  testShortName = $testName
                  platformName = $linuxPlatform.name
                  agentImage = $linuxPlatform.image
                  scriptName = $linuxPlatform.script
                }
              }

              $linuxMatrixJson = $linuxMatrix | ConvertTo-Json -Compress
              Write-Host "Generated Linux matrix: $linuxMatrixJson"

              # Set pipeline variable for Linux matrix
              Write-Host "##vso[task.setVariable variable=linuxTestsMatrix;isOutput=true]$linuxMatrixJson"
            displayName: 'Generate test matrix'
            name: 'GenerateMatrix'

  - stage: SetupWindows
    displayName: 'Setup Windows'
    jobs:
      - job: SetupDotNetWindows
        displayName: 'Setup .NET SDK - Windows'
        pool:
          name: $(DncEngPublicBuildPool)
          demands: ImageOverride -equals windows.vs2022preview.amd64.open

        steps:
          - checkout: self
            fetchDepth: 1
            clean: true

          - pwsh: |
              ./restore.cmd
            displayName: 'Restore .NET SDK'

          - task: PublishPipelineArtifact@1
            displayName: 'Publish .NET SDK - Windows'
            inputs:
              targetPath: '$(Build.SourcesDirectory)/.dotnet'
              artifactName: 'dotnet-sdk-windows'
              publishLocation: 'pipeline'

      - job: EnumerateIntegrationTestsWindows
        displayName: 'Enumerate Integration Tests - Windows'
        pool:
          name: $(DncEngPublicBuildPool)
          demands: ImageOverride -equals windows.vs2022preview.amd64.open

        steps:
          - checkout: self
            fetchDepth: 1
            clean: true

          - pwsh: |
              ./restore.cmd
            displayName: 'Restore .NET SDK'

          - pwsh: |
              ./dotnet.cmd build tests/Shared/GetTestProjects.proj /bl:$(Build.Arcade.LogsPath)/GetTestProjects.binlog /p:TestsListOutputPath=$(Build.Arcade.ArtifactsPath)/IntegrationTests.list /p:ContinuousIntegrationBuild=true
            displayName: 'Generate integration tests list'

          - pwsh: |
              $testsListFile = "$(Build.Arcade.ArtifactsPath)/IntegrationTests.list"
              if (-not (Test-Path $testsListFile)) {
                throw "Tests list file not found: $testsListFile"
              }

              $testNames = Get-Content $testsListFile | Where-Object { $_.Trim() -ne "" } | Sort-Object
              if ($testNames.Count -eq 0) {
                throw "No integration tests found"
              }

              Write-Host "Found $($testNames.Count) integration test projects:"
              $testNames | ForEach-Object { Write-Host "  - $_" }

              # Create Windows matrix only
              $windowsMatrix = @{}
              $windowsPlatform = @{ name = 'Windows'; image = 'windows.vs2022preview.amd64.open'; script = 'dotnet.cmd' }

              foreach ($testName in $testNames) {
                $windowsKey = "$testName`_Windows"
                $windowsMatrix[$windowsKey] = @{
                  testShortName = $testName
                  platformName = $windowsPlatform.name
                  agentImage = $windowsPlatform.image
                  scriptName = $windowsPlatform.script
                }
              }

              $windowsMatrixJson = $windowsMatrix | ConvertTo-Json -Compress
              Write-Host "Generated Windows matrix: $windowsMatrixJson"

              # Set pipeline variable for Windows matrix
              Write-Host "##vso[task.setVariable variable=windowsTestsMatrix;isOutput=true]$windowsMatrixJson"
            displayName: 'Generate Windows test matrix'
            name: 'GenerateMatrix'

  # ----------------------------------------------------------------
  # Linux Tests Stage
  # ----------------------------------------------------------------
  - stage: LinuxTests
    displayName: 'Linux Integration Tests'
    dependsOn: SetupLinux
    jobs:
      - job: RunIntegrationTestsLinux
        displayName: 'Test'
        strategy:
          matrix: $[ stageDependencies.SetupLinux.EnumerateIntegrationTests.outputs['GenerateMatrix.linuxTestsMatrix'] ]

        timeoutInMinutes: 20

        pool:
          name: $(DncEngPublicBuildPool)
          demands: ImageOverride -equals $(agentImage)

        steps:
          - checkout: self
            fetchDepth: 1
            clean: true

          - task: DownloadPipelineArtifact@2
            displayName: 'Download .NET SDK - Linux'
            inputs:
              artifactName: 'dotnet-sdk-linux'
              targetPath: '$(Build.SourcesDirectory)/.dotnet'

          - script: chmod +x $(Build.SourcesDirectory)/.dotnet/dotnet
            displayName: 'Fix .NET permissions'

          - task: DockerInstaller@0
            inputs:
              dockerVersion: '28.0.0'
            displayName: 'Install Docker CLI'

          - script: $(Build.SourcesDirectory)/tests/external-scripts/ubuntu-create-dotnet-devcert.sh
            displayName: 'Install devcerts'
            continueOnError: true

          - pwsh: |
              # Handle both Aspire.*.Tests and *.Tests naming patterns
              $testShortName = "$(testShortName)"
              $testProject = if (Test-Path "tests/Aspire.$testShortName.Tests/Aspire.$testShortName.Tests.csproj") {
                "tests/Aspire.$testShortName.Tests/Aspire.$testShortName.Tests.csproj"
              } elseif (Test-Path "tests/$testShortName.Tests/$testShortName.Tests.csproj") {
                "tests/$testShortName.Tests/$testShortName.Tests.csproj"
              } else {
                throw "Could not find test project for: $testShortName"
              }
              Write-Host "Running test project: $testProject"

              # Use the downloaded .NET SDK directly
              $filter = "Category!=quarantined&Category!=outerloop"
              & "$(Build.SourcesDirectory)/.dotnet/dotnet" test $testProject --configuration $(_BuildConfig) --logger "trx;LogFileName=$(testShortName)-$(platformName).trx" --logger "console;verbosity=normal" --results-directory "$(Build.Arcade.TestResultsPath)" --filter $filter
            displayName: 'Run tests'
            env:
              DOCKER_BUILDKIT: 1
              DOTNET_ASPIRE_DEPENDENCY_CHECK_TIMEOUT: 180
              DCP_DIAGNOSTICS_LOG_LEVEL: debug
              DCP_DIAGNOSTICS_LOG_FOLDER: $(Build.ArtifactStagingDirectory)/artifacts/log/dcp
              DCP_PRESERVE_EXECUTABLE_LOGS: 1
              DOTNET_ROOT: $(Build.SourcesDirectory)/.dotnet
              PATH: $(Build.SourcesDirectory)/.dotnet:$(PATH)
            timeoutInMinutes: 15

          - task: PublishTestResults@2
            displayName: 'Publish test results'
            condition: always()
            inputs:
              testResultsFormat: 'VSTest'
              testResultsFiles: '$(Build.Arcade.TestResultsPath)/$(testShortName)-$(platformName).trx'
              testRunTitle: 'Integration Tests'
              mergeTestResults: false
              failTaskOnFailedTests: true

  # ----------------------------------------------------------------
  # Windows Tests Stage
  # ----------------------------------------------------------------
  - stage: WindowsTests
    displayName: 'Windows Integration Tests'
    dependsOn: SetupWindows
    jobs:
      - job: RunIntegrationTestsWindows
        displayName: 'Test'
        strategy:
          matrix: $[ stageDependencies.SetupWindows.EnumerateIntegrationTestsWindows.outputs['GenerateMatrix.windowsTestsMatrix'] ]

        timeoutInMinutes: 20

        pool:
          name: $(DncEngPublicBuildPool)
          demands: ImageOverride -equals $(agentImage)

        steps:
          - checkout: self
            fetchDepth: 1
            clean: true

          - task: DownloadPipelineArtifact@2
            displayName: 'Download .NET SDK - Windows'
            inputs:
              artifactName: 'dotnet-sdk-windows'
              targetPath: '$(Build.SourcesDirectory)/.dotnet'

          - script: dotnet dev-certs https
            displayName: 'Install dev-certs'
            continueOnError: true

          - pwsh: |
              # Handle both Aspire.*.Tests and *.Tests naming patterns
              $testShortName = "$(testShortName)"
              $testProject = if (Test-Path "tests/Aspire.$testShortName.Tests/Aspire.$testShortName.Tests.csproj") {
                "tests/Aspire.$testShortName.Tests/Aspire.$testShortName.Tests.csproj"
              } elseif (Test-Path "tests/$testShortName.Tests/$testShortName.Tests.csproj") {
                "tests/$testShortName.Tests/$testShortName.Tests.csproj"
              } else {
                throw "Could not find test project for: $testShortName"
              }
              Write-Host "Running test project: $testProject"

              # Use the downloaded .NET SDK directly, escape the filter properly for PowerShell
              $filter = "Category!=quarantined`&Category!=outerloop"
              & "$(Build.SourcesDirectory)/.dotnet/dotnet.exe" test $testProject --configuration $(_BuildConfig) --logger "trx;LogFileName=$(testShortName)-$(platformName).trx" --logger "console;verbosity=normal" --results-directory "$(Build.Arcade.TestResultsPath)" --filter $filter
            displayName: 'Run tests'
            env:
              DOCKER_BUILDKIT: 1
              DOTNET_ASPIRE_DEPENDENCY_CHECK_TIMEOUT: 180
              DCP_DIAGNOSTICS_LOG_LEVEL: debug
              DCP_DIAGNOSTICS_LOG_FOLDER: $(Build.ArtifactStagingDirectory)/artifacts/log/dcp
              DCP_PRESERVE_EXECUTABLE_LOGS: 1
              DOTNET_ROOT: $(Build.SourcesDirectory)/.dotnet
              PATH: $(Build.SourcesDirectory)/.dotnet:$(PATH)
            timeoutInMinutes: 15

          - task: PublishTestResults@2
            displayName: 'Publish test results'
            condition: always()
            inputs:
              testResultsFormat: 'VSTest'
              testResultsFiles: '$(Build.Arcade.TestResultsPath)/$(testShortName)-$(platformName).trx'
              testRunTitle: 'Integration Tests'
              mergeTestResults: false
              failTaskOnFailedTests: true
