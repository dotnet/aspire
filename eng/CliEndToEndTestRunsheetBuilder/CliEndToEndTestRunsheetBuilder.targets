<Project>
  <!--
    This file is used to generate a test runsheet for CLI End-to-End tests that fans out
    each test class to a separate CI job.

    Usage:
         ./build.sh -test /p:TestRunnerName=CliEndToEndTestRunsheetBuilder -c Release

    This runsheet builder:
    1. Executes the test assembly with the list-tests argument to get all test methods
    2. Extracts unique test class names from the output
    3. Generates a JSON runsheet entry for each test class
    4. Each test class runs as a separate GitHub Actions job

    The final runsheet is combined in eng/AfterSolutionBuild.targets.
  -->

  <Target Name="RunTests"
          Outputs="%(TestToRun.ResultsStdOutPath)"
          Condition=" '$(SkipTests)' != 'true' and '$(IsGitHubActionsRunner)' == 'true' and '$(RunOnGithubActions)' == 'true' and '$(MSBuildProjectName)' == 'Aspire.Cli.EndToEndTests' ">

    <PropertyGroup>
      <_TestEnvironment>%(TestToRun.EnvironmentDisplay)</_TestEnvironment>
      <_TestAssembly>%(TestToRun.Identity)</_TestAssembly>
      <_TestAssembly Condition="'$(OS)'=='Windows_NT'">$([System.IO.Path]::ChangeExtension($(_TestAssembly), '.exe'))</_TestAssembly>
      <_TestAssembly Condition="'$(OS)'!='Windows_NT'">$(_TestAssembly.TrimEnd('.dll'))</_TestAssembly>
      <_TestTimeout>%(TestToRun.TestTimeout)</_TestTimeout>

      <_TargetDir>$([System.IO.Path]::GetDirectoryName('$(_TestAssembly)'))\</_TargetDir>

      <_TestRunnerCommand>$(_TestAssembly) --list-tests --filter-not-trait "quarantined=true" --filter-not-trait "outerloop=true"</_TestRunnerCommand>

      <!--
        Redirect std output of the runner.
        -->
      <_TestRunnerCommand Condition="'$(TestCaptureOutput)' != 'false'">$(_TestRunnerCommand) >> "%(TestToRun.ResultsStdOutPath)" 2>&amp;1</_TestRunnerCommand>
    </PropertyGroup>

    <ItemGroup>
      <_OutputFiles Include="%(TestToRun.ResultsStdOutPath)" />
    </ItemGroup>

    <MakeDir Directories="@(_OutputFiles->'%(RootDir)%(Directory)')"/>
    <Delete Files="@(_OutputFiles)" />

    <!--
      Add command line to the log.
      -->
    <Exec Command="echo === COMMAND LINE === > %(TestToRun.ResultsStdOutPath)
                   echo $(_TestRunnerCommand) >> %(TestToRun.ResultsStdOutPath)" />

    <Message Text="Discovering CLI E2E tests: $(_TestAssembly) [$(_TestEnvironment)]" Importance="high"/>
    <Exec Command='$(_TestRunnerCommand)'
          LogStandardErrorAsError="false"
          WorkingDirectory="$(_TargetDir)"
          IgnoreExitCode="true"
          Timeout="$(_TestTimeout)"
          EnvironmentVariables="DOTNET_ROOT=$(DotNetRoot);DOTNET_ROOT_X86=$(DotNetRoot)x86"
          ContinueOnError="WarnAndContinue">
      <Output TaskParameter="ExitCode" PropertyName="_TestErrorCode" />
    </Exec>

    <PropertyGroup>
      <_ResultsFileToDisplay>%(TestToRun.ResultsStdOutPath)</_ResultsFileToDisplay>
    </PropertyGroup>

    <!--
      Report test status.
      -->
    <Message Text="Discovery complete, no CLI E2E tests found: $(_TestAssembly) [$(_TestEnvironment)]" Condition="'$(_TestErrorCode)' == '8'" Importance="high" />
    <Message Text="ðŸ’¡ Discovery complete, CLI E2E tests found: $(_TestAssembly) [$(_TestEnvironment)]" Condition="'$(_TestErrorCode)' == '0'" Importance="high" />
    <Error Text="Discovery failed: $(_ResultsFileToDisplay) [$(_TestEnvironment)]" Condition=" '$(_TestErrorCode)' != '0' and '$(_TestErrorCode)' != '8' " File="CliEndToEndTestRunsheetBuilder" />

    <PropertyGroup>
      <_HasTests>true</_HasTests>
      <_HasTests Condition=" '$(_TestErrorCode)' == '8' ">false</_HasTests>
    </PropertyGroup>

    <!--
      Extract unique test class names from the test list output and generate per-class runsheets.
      This is done via a PowerShell script because MSBuild is not well-suited for text parsing.
      -->
    <PropertyGroup Condition=" '$(_HasTests)' == 'true' ">
      <_TestRunsheet>Cli.EndToEnd</_TestRunsheet>
      <_TestBinLog>$([MSBuild]::NormalizePath($(ArtifactsLogDir), 'Cli.EndToEnd.binlog'))</_TestBinLog>

      <_RelativeTestProjectPath>$([System.String]::Copy('$(MSBuildProjectFullPath)').Replace('$(RepoRoot)', '%24(pwd)/'))</_RelativeTestProjectPath>
      <_RelativeTestBinLog>$([System.String]::Copy('$(_TestBinLog)').Replace('$(RepoRoot)', '%24(pwd)/'))</_RelativeTestBinLog>

      <_RequiresNugets>true</_RequiresNugets>
      <_RequiresTestSdk>true</_RequiresTestSdk>

      <_ExtractTestClassesScript>$(MSBuildThisFileDirectory)extract-test-classes.ps1</_ExtractTestClassesScript>
    </PropertyGroup>

    <Exec Command="pwsh -File $(_ExtractTestClassesScript) -TestOutputPath '%(TestToRun.ResultsStdOutPath)' -ArtifactsTmpDir '$(ArtifactsTmpDir)' -RelativeTestProjectPath '$(_RelativeTestProjectPath)' -RelativeTestBinLog '$(_RelativeTestBinLog)' -Configuration '$(Configuration)'"
          Condition=" '$(_HasTests)' == 'true' "
          ConsoleToMSBuild="true">
      <Output TaskParameter="ConsoleOutput" PropertyName="_ExtractOutput" />
    </Exec>

    <Message Importance="high" Text="$(_ExtractOutput)" Condition=" '$(_HasTests)' == 'true' " />

    <!--
      The final piece of the puzzle is in eng/AfterSolutionBuild.targets, where we combine the runsheets from all the test projects into a single runsheet.
      -->
  </Target>

</Project>
