<Project>
  <!--
    This file is used to generate a test runsheet for CLI End-to-End tests that fans out
    each test class to a separate CI job.

    Usage:
         ./build.sh -test /p:TestRunnerName=CliEndToEndTestRunsheetBuilder -c Release

    This runsheet builder:
    1. Executes the test assembly with --list-tests to get all test methods
    2. Extracts unique test class names from the output
    3. Generates a JSON runsheet entry for each test class
    4. Each test class runs as a separate GitHub Actions job

    The final runsheet is combined in eng/AfterSolutionBuild.targets.
  -->

  <Target Name="RunTests"
          Outputs="%(TestToRun.ResultsStdOutPath)"
          Condition=" '$(SkipTests)' != 'true' and '$(IsGitHubActionsRunner)' == 'true' and '$(RunOnGithubActions)' == 'true' and '$(MSBuildProjectName)' == 'Aspire.Cli.EndToEndTests' ">

    <PropertyGroup>
      <_TestEnvironment>%(TestToRun.EnvironmentDisplay)</_TestEnvironment>
      <_TestAssembly>%(TestToRun.Identity)</_TestAssembly>
      <_TestAssembly Condition="'$(OS)'=='Windows_NT'">$([System.IO.Path]::ChangeExtension($(_TestAssembly), '.exe'))</_TestAssembly>
      <_TestAssembly Condition="'$(OS)'!='Windows_NT'">$(_TestAssembly.TrimEnd('.dll'))</_TestAssembly>
      <_TestTimeout>%(TestToRun.TestTimeout)</_TestTimeout>

      <_TargetDir>$([System.IO.Path]::GetDirectoryName('$(_TestAssembly)'))\</_TargetDir>

      <_TestRunnerCommand>$(_TestAssembly) --list-tests --filter-not-trait "quarantined=true" --filter-not-trait "outerloop=true"</_TestRunnerCommand>

      <!--
        Redirect std output of the runner.
        -->
      <_TestRunnerCommand Condition="'$(TestCaptureOutput)' != 'false'">$(_TestRunnerCommand) >> "%(TestToRun.ResultsStdOutPath)" 2>&amp;1</_TestRunnerCommand>
    </PropertyGroup>

    <ItemGroup>
      <_OutputFiles Include="%(TestToRun.ResultsStdOutPath)" />
    </ItemGroup>

    <MakeDir Directories="@(_OutputFiles->'%(RootDir)%(Directory)')"/>
    <Delete Files="@(_OutputFiles)" />

    <!--
      Add command line to the log.
      -->
    <Exec Command="echo === COMMAND LINE === > %(TestToRun.ResultsStdOutPath)
                   echo $(_TestRunnerCommand) >> %(TestToRun.ResultsStdOutPath)" />

    <Message Text="Discovering CLI E2E tests: $(_TestAssembly) [$(_TestEnvironment)]" Importance="high"/>
    <Exec Command='$(_TestRunnerCommand)'
          LogStandardErrorAsError="false"
          WorkingDirectory="$(_TargetDir)"
          IgnoreExitCode="true"
          Timeout="$(_TestTimeout)"
          EnvironmentVariables="DOTNET_ROOT=$(DotNetRoot);DOTNET_ROOT_X86=$(DotNetRoot)x86"
          ContinueOnError="WarnAndContinue">
      <Output TaskParameter="ExitCode" PropertyName="_TestErrorCode" />
    </Exec>

    <PropertyGroup>
      <_ResultsFileToDisplay>%(TestToRun.ResultsStdOutPath)</_ResultsFileToDisplay>
    </PropertyGroup>

    <!--
      Report test status.
      -->
    <Message Text="Discovery complete, no CLI E2E tests found: $(_TestAssembly) [$(_TestEnvironment)]" Condition="'$(_TestErrorCode)' == '8'" Importance="high" />
    <Message Text="ðŸ’¡ Discovery complete, CLI E2E tests found: $(_TestAssembly) [$(_TestEnvironment)]" Condition="'$(_TestErrorCode)' == '0'" Importance="high" />
    <Error Text="Discovery failed: $(_ResultsFileToDisplay) [$(_TestEnvironment)]" Condition=" '$(_TestErrorCode)' != '0' and '$(_TestErrorCode)' != '8' " File="CliEndToEndTestRunsheetBuilder" />

    <PropertyGroup>
      <_HasTests>true</_HasTests>
      <_HasTests Condition=" '$(_TestErrorCode)' == '8' ">false</_HasTests>
    </PropertyGroup>

    <!--
      Extract unique test class names from the test list output and generate per-class runsheets.
      This is done via a PowerShell script because MSBuild is not well-suited for text parsing.
      -->
    <PropertyGroup Condition=" '$(_HasTests)' == 'true' ">
      <_TestRunsheet>Cli.EndToEnd</_TestRunsheet>
      <_TestBinLog>$([MSBuild]::NormalizePath($(ArtifactsLogDir), 'Cli.EndToEnd.binlog'))</_TestBinLog>

      <_RelativeTestProjectPath>$([System.String]::Copy('$(MSBuildProjectFullPath)').Replace('$(RepoRoot)', '%24(pwd)/'))</_RelativeTestProjectPath>
      <_RelativeTestBinLog>$([System.String]::Copy('$(_TestBinLog)').Replace('$(RepoRoot)', '%24(pwd)/'))</_RelativeTestBinLog>

      <_RequiresNugets>true</_RequiresNugets>
      <_RequiresTestSdk>true</_RequiresTestSdk>

      <_ExtractTestClassesScript>$(ArtifactsTmpDir)/extract-cli-e2e-test-classes.ps1</_ExtractTestClassesScript>
      <_ExtractTestClassesCommand>
        # Read the test list output
        $testOutput = Get-Content -Path '%(TestToRun.ResultsStdOutPath)' -Raw

        # Extract test class names using regex (format: Namespace.ClassName.MethodName or Namespace.ClassName.MethodName(params))
        $pattern = '^\s*(Aspire\.Cli\.EndToEndTests\.[^\.\(]+)'
        $matches = [regex]::Matches($testOutput, $pattern, 'Multiline')

        # Get unique class names
        $classNames = $matches | ForEach-Object { $_.Groups[1].Value } | Sort-Object -Unique

        if ($classNames.Count -eq 0) {
            Write-Host "No test classes found"
            exit 0
        }

        Write-Host "Found $($classNames.Count) test class(es):"
        $classNames | ForEach-Object { Write-Host "  - $_" }

        # Generate a runsheet entry for each test class
        foreach ($className in $classNames) {
            $shortName = $className -replace '^Aspire\.Cli\.EndToEndTests\.', ''
            $filterArg = "--filter-class `"$className`""

            # Only generate Linux runsheet since Hex1b requires Linux
            $runsheetLinux = @{
                label = "l: Cli.E2E.$shortName"
                project = "Cli.EndToEnd.$shortName"
                os = "ubuntu-latest"
                command = "./eng/build.sh -restore -build -test -projects `"$(_RelativeTestProjectPath)`" /bl:`"$(_RelativeTestBinLog -replace 'Cli\.EndToEnd', "Cli.EndToEnd.$shortName")`" -c $(Configuration) -ci /p:TestsRunningOutsideOfRepo=true -- $filterArg"
                requiresNugets = $true
                requiresTestSdk = $true
            }

            $jsonLinux = $runsheetLinux | ConvertTo-Json -Compress
            $outputFileLinux = "$(ArtifactsTmpDir)/Cli.EndToEnd.$shortName.linux.runsheet.json"
            $jsonLinux | Set-Content -Path $outputFileLinux -Encoding UTF8
            Write-Host "Generated runsheet: $outputFileLinux"
        }
      </_ExtractTestClassesCommand>
    </PropertyGroup>

    <WriteLinesToFile
            Condition=" '$(_HasTests)' == 'true' "
            File="$(_ExtractTestClassesScript)"
            Lines="$(_ExtractTestClassesCommand)"
            Overwrite="true" />

    <Exec Command="pwsh -File $(_ExtractTestClassesScript)"
          Condition=" '$(_HasTests)' == 'true' "
          ConsoleToMSBuild="true">
      <Output TaskParameter="ConsoleOutput" PropertyName="_ExtractOutput" />
    </Exec>

    <Message Importance="high" Text="$(_ExtractOutput)" Condition=" '$(_HasTests)' == 'true' " />

    <!--
      The final piece of the puzzle is in eng/AfterSolutionBuild.targets, where we combine the runsheets from all the test projects into a single runsheet.
      -->
  </Target>

</Project>
