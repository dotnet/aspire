<Project>
  <!--

    This file is used to generate a list of tests to run on GitHub Actions.

    - For projects not requiring packages:
         .\build.cmd -test /p:TestRunnerName=TestRunsheetBuilder [/bl /p:GITHUB_ACTIONS=true]

    - For projects requiring packages (e.g., E2E, templates and playground):
         .\build.cmd -test /p:TestRunnerName=TestRunsheetBuilder /p:FullE2e=true [/bl /p:GITHUB_ACTIONS=true]

    For the large part this is a copy of the Arcade SDK's implementations:
      - https://github.com/dotnet/arcade/blob/b888df17/src/Microsoft.DotNet.Arcade.Sdk/tools/XUnit/XUnit.Runner.targets
      - https://github.com/dotnet/arcade/blob/b888df17/src/Microsoft.DotNet.Arcade.Sdk/tools/VSTest.targets
   -->

  <Target Name="RunTests"
          Outputs="%(TestToRun.ResultsStdOutPath)"
          Condition=" '$(SkipTests)' != 'true' and '$(IsGitHubActionsRunner)' == 'true' and '$(RunOnGithubActions)' == 'true' ">

    <PropertyGroup>
      <!--

        The runsheet is created in two scenarios:
        - For projects requiring packages, only if full end-to-end tests (`FullE2e`) are enabled.
        - For projects not requiring packages, only if full end-to-end tests (`FullE2e`) are disabled.

        This logic ensures runsheets are generated appropriately based on the project's characteristics and the testing scenario.

        FIXME: Aspire.Playground.Tests are currently not running in "out of repo" mode.
        FIXME: Aspire.Templates.Tests are currently left alone.

        -->
      <_RequiresPackages Condition=" '$(MSBuildProjectName)' == 'Aspire.EndToEnd.Tests' ">true</_RequiresPackages>

      <_CreateRunsheet>false</_CreateRunsheet>
      <_CreateRunsheet Condition=" '$(_RequiresPackages)' == 'true' and '$(FullE2e)' == 'true' ">true</_CreateRunsheet>
      <_CreateRunsheet Condition=" '$(_RequiresPackages)' != 'true' and '$(FullE2e)' != 'true' ">true</_CreateRunsheet>

      <_CreateRunsheet Condition=" '$(MSBuildProjectName)' == 'Aspire.Templates.Tests' ">false</_CreateRunsheet>

      <_PreCommand>$(TestRunnerPreCommand)</_PreCommand>
    </PropertyGroup>

    <!-- Sharding detection for the current project -->
    <ItemGroup>
      <_ThisShardedProject Include="@(ShardedTestProject)" Condition=" '%(ShardedTestProject.Identity)' == '$(MSBuildProjectName)' " />
    </ItemGroup>
    <PropertyGroup>
      <_IsSharded>false</_IsSharded>
      <_IsSharded Condition=" '@(_ThisShardedProject)' != '' ">true</_IsSharded>
      <_ShardCountForThisProject>@(_ThisShardedProject->'%(ShardCount)')</_ShardCountForThisProject>
    </PropertyGroup>

    <PropertyGroup>
      <!--
        We do not care whether the project is multi-targeting, we're only generating a command to kick off the testing sequence,
        which in turn will run the tests for all the target frameworks.

        So, instead of using "%(TestToRun.ResultsFilePathWithoutExtension)" (which looks something like "Aspire.Cli.Tests_net8.0_x64")
        we use the project name (which looks something like "Aspire.Cli.Tests").
        -->
      <_TestRunsheet>$([System.String]::Copy('$(MSBuildProjectName)').Replace('Aspire.', ''))</_TestRunsheet>
      <_TestRunsheetFileNameWindows>$(ArtifactsTmpDir)/$(_TestRunsheet).win.runsheet.json</_TestRunsheetFileNameWindows>
      <_TestRunsheetFileNameLinux>$(ArtifactsTmpDir)/$(_TestRunsheet).linux.runsheet.json</_TestRunsheetFileNameLinux>
      <_TestRunsheetFileNameMacOS>$(ArtifactsTmpDir)/$(_TestRunsheet).macos.runsheet.json</_TestRunsheetFileNameMacOS>

      <_TestBinLog>$([MSBuild]::NormalizePath($(ArtifactsLogDir), '$(_TestRunsheet).binlog'))</_TestBinLog>

      <_RelativeTestProjectPath>$([System.String]::Copy('$(MSBuildProjectFullPath)').Replace('$(RepoRoot)', '%24(pwd)/'))</_RelativeTestProjectPath>
      <_RelativeTestBinLog>$([System.String]::Copy('$(_TestBinLog)').Replace('$(RepoRoot)', '%24(pwd)/'))</_RelativeTestBinLog>

      <_TestRunnerWindows>pwsh</_TestRunnerWindows>
      <_TestRunnerLinux>bash</_TestRunnerLinux>
      <_TestRunnerMacOS>bash</_TestRunnerMacOS>
      <_TestCommand>-restore -build -test -projects &quot;$(_RelativeTestProjectPath)&quot; /bl:&quot;$(_RelativeTestBinLog)&quot; -c $(Configuration) -ci</_TestCommand>

      <!-- Tests requiring packages must be run in the "out of repo" mode -->
      <_TestCommand Condition=" '$(_RequiresPackages)' == 'true' ">$(_TestCommand) /p:TestsRunningOutsideOfRepo=true</_TestCommand>

      <!-- Replace \ with /, and then escape " with \", so we have a compliant JSON -->
      <_PreCommand>$([System.String]::Copy($(_PreCommand)).Replace("\", "/").Replace('&quot;', '\"'))</_PreCommand>
      <_TestCommand>$([System.String]::Copy($(_TestCommand)).Replace("\", "/").Replace('&quot;', '\"'))</_TestCommand>

      <!-- Handle empty PreCommand for proper command syntax -->
      <_WindowsPreCommandPart Condition=" '$(_PreCommand)' != '' ">$([System.String]::Copy($(_PreCommand)).Replace('"', '\\"')) ; </_WindowsPreCommandPart>
      <_WindowsPreCommandPart Condition=" '$(_PreCommand)' == '' "></_WindowsPreCommandPart>
      <_UnixPreCommandPart Condition=" '$(_PreCommand)' != '' ">$(_PreCommand) </_UnixPreCommandPart>
      <_UnixPreCommandPart Condition=" '$(_PreCommand)' == '' "></_UnixPreCommandPart>

      <_TestRunsheetWindows>{ "label": "w: $(_TestRunsheet)", "project": "$(_TestRunsheet)", "os": "windows-latest", "command": "pwsh -NoProfile -Command \"$(_WindowsPreCommandPart)./eng/build.ps1 $(_TestCommand)\"" }</_TestRunsheetWindows>
      <_TestRunsheetLinux>{ "label": "l: $(_TestRunsheet)", "project": "$(_TestRunsheet)", "os": "ubuntu-latest", "command": "$(_UnixPreCommandPart)./eng/build.sh $(_TestCommand)" }</_TestRunsheetLinux>
      <_TestRunsheetMacOS>{ "label": "m: $(_TestRunsheet)", "project": "$(_TestRunsheet)", "os": "macos-latest", "command": "$(_UnixPreCommandPart)./eng/build.sh $(_TestCommand)" }</_TestRunsheetMacOS>
    </PropertyGroup>

    <ItemGroup>
      <_OutputFiles Include="$(_TestRunsheetFileNameWindows)" />
      <_OutputFiles Include="$(_TestRunsheetFileNameLinux)" />
      <_OutputFiles Include="$(_TestRunsheetFileNameMacOS)" />
    </ItemGroup>

    <MakeDir Directories="@(_OutputFiles->'%(RootDir)%(Directory)')"/>
    <Delete Files="@(_OutputFiles)" />

    <WriteLinesToFile
            Condition=" '$(RunOnGithubActionsWindows)' == 'true' and '$(_CreateRunsheet)' == 'true' and '$(_IsSharded)' != 'true' "
            File="$(_TestRunsheetFileNameWindows)"
            Lines="$(_TestRunsheetWindows)"
            Overwrite="true"
            WriteOnlyWhenDifferent="true" />
    <WriteLinesToFile
            Condition=" '$(RunOnGithubActionsLinux)' == 'true' and '$(_CreateRunsheet)' == 'true' and '$(_IsSharded)' != 'true' "
            File="$(_TestRunsheetFileNameLinux)"
            Lines="$(_TestRunsheetLinux)"
            Overwrite="true"
            WriteOnlyWhenDifferent="true" />
    <WriteLinesToFile
            Condition=" '$(RunOnGithubActionsMacOS)' == 'true' and '$(_CreateRunsheet)' == 'true' and '$(_IsSharded)' != 'true' "
            File="$(_TestRunsheetFileNameMacOS)"
            Lines="$(_TestRunsheetMacOS)"
            Overwrite="true"
            WriteOnlyWhenDifferent="true" />

    <!-- Sharded projects: generate per-shard entries per OS using inline task -->


    <!-- Generate sharded runsheets using the inline task -->
    <GenerateShardedRunsheet
        Condition=" '$(RunOnGithubActionsWindows)' == 'true' and '$(_CreateRunsheet)' == 'true' and '$(_IsSharded)' == 'true' and '$(_ShardCountForThisProject)' != '' "
        Project="$(_TestRunsheet)"
        ShardCount="$(_ShardCountForThisProject)"
        PreCommand="$(_PreCommand)"
        TestCommand="$(_TestCommand)"
        Os="windows-latest"
        OsPrefix="w"
        OutputFile="$(_TestRunsheetFileNameWindows)" />

    <GenerateShardedRunsheet
        Condition=" '$(RunOnGithubActionsLinux)' == 'true' and '$(_CreateRunsheet)' == 'true' and '$(_IsSharded)' == 'true' and '$(_ShardCountForThisProject)' != '' "
        Project="$(_TestRunsheet)"
        ShardCount="$(_ShardCountForThisProject)"
        PreCommand="$(_PreCommand)"
        TestCommand="$(_TestCommand)"
        Os="ubuntu-latest"
        OsPrefix="l"
        OutputFile="$(_TestRunsheetFileNameLinux)" />

    <GenerateShardedRunsheet
        Condition=" '$(RunOnGithubActionsMacOS)' == 'true' and '$(_CreateRunsheet)' == 'true' and '$(_IsSharded)' == 'true' and '$(_ShardCountForThisProject)' != '' "
        Project="$(_TestRunsheet)"
        ShardCount="$(_ShardCountForThisProject)"
        PreCommand="$(_PreCommand)"
        TestCommand="$(_TestCommand)"
        Os="macos-latest"
        OsPrefix="m"
        OutputFile="$(_TestRunsheetFileNameMacOS)" />

    <!--
      The final piece of the puzzle is in eng/AfterSolutionBuild.targets, where we combine the runsheets from all the test projects into a single runsheet.
      -->
  </Target>

  <!-- Custom inline task to generate sharded JSON runsheets -->
  <UsingTask TaskName="GenerateShardedRunsheet" TaskFactory="RoslynCodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <Project ParameterType="System.String" Required="true" />
      <ShardCount ParameterType="System.Int32" Required="true" />
      <PreCommand ParameterType="System.String" Required="false" />
      <TestCommand ParameterType="System.String" Required="true" />
      <Os ParameterType="System.String" Required="true" />
      <OsPrefix ParameterType="System.String" Required="true" />
      <OutputFile ParameterType="System.String" Required="true" />
    </ParameterGroup>
    <Task>
      <Code Type="Class" Language="cs">
        <![CDATA[
          using System;
          using System.Collections.Generic;
          using System.IO;
          using System.Text;
          using Microsoft.Build.Framework;
          using Microsoft.Build.Utilities;

          public class GenerateShardedRunsheet : Task
          {
              public string Project { get; set; }
              public int ShardCount { get; set; }
              public string PreCommand { get; set; }
              public string TestCommand { get; set; }
              public string Os { get; set; }
              public string OsPrefix { get; set; }
              public string OutputFile { get; set; }

              public override bool Execute()
              {
                  var jsonBuilder = new StringBuilder();
                  jsonBuilder.AppendLine("[");

                  for (int i = 0; i < ShardCount; i++)
                  {
                      string label = $"{OsPrefix}: {Project} [shard {i}/{ShardCount}]";
                      string command;

                      // Handle empty or null PreCommand
                      string preCommand = string.IsNullOrEmpty(PreCommand) ? "" : PreCommand;

                      if (Os == "windows-latest")
                      {
                          // For Windows, we need to build a PowerShell command
                          string envVars = $"$env:ASPIRE_SHARD_COUNT={ShardCount}; $env:ASPIRE_SHARD_INDEX={i}";
                          string fullCommand = string.IsNullOrEmpty(preCommand)
                              ? $"{envVars}; ./eng/build.ps1 {TestCommand}"
                              : $"{envVars}; {preCommand}; ./eng/build.ps1 {TestCommand}";
                          command = $"pwsh -NoProfile -Command \"{fullCommand.Replace("\"", "\\\"")}\"";
                      }
                      else
                      {
                          // For Unix systems
                          string envVars = $"ASPIRE_SHARD_COUNT={ShardCount} ASPIRE_SHARD_INDEX={i}";
                          string preCommandPart = string.IsNullOrEmpty(preCommand) ? "" : $"{preCommand} ";
                          command = $"{envVars} {preCommandPart}./eng/build.sh {TestCommand}";
                      }

                      // Create JSON object manually to ensure proper escaping
                      jsonBuilder.AppendLine("  {");
                      jsonBuilder.AppendLine($"    \"label\": {EscapeAndQuoteJsonString(label)},");
                      jsonBuilder.AppendLine($"    \"project\": {EscapeAndQuoteJsonString(Project)},");
                      jsonBuilder.AppendLine($"    \"os\": {EscapeAndQuoteJsonString(Os)},");
                      jsonBuilder.AppendLine($"    \"command\": {EscapeAndQuoteJsonString(command)}");

                      if (i < ShardCount - 1)
                      {
                          jsonBuilder.AppendLine("  },");
                      }
                      else
                      {
                          jsonBuilder.AppendLine("  }");
                      }
                  }

                  jsonBuilder.AppendLine("]");

                  Directory.CreateDirectory(Path.GetDirectoryName(OutputFile));
                  File.WriteAllText(OutputFile, jsonBuilder.ToString());

                  return true;
              }

              private string EscapeAndQuoteJsonString(string input)
              {
                  if (string.IsNullOrEmpty(input))
                      return "\"\"";

                  // The TestCommand coming from MSBuild already has some escaping
                  // We need to be careful not to double-escape
                  string escaped = input
                      .Replace("\"", "\\\"")  // Escape quotes
                      .Replace("\n", "\\n")   // Escape newline
                      .Replace("\r", "\\r")   // Escape carriage return
                      .Replace("\t", "\\t");  // Escape tab

                  return $"\"{escaped}\"";
              }
          }
        ]]>
      </Code>
    </Task>
  </UsingTask>
</Project>
