# This workflow identifies open PRs that need review and updates a tracking issue with the list.
#
# A PR is considered "needing review" when:
# - It is not a draft
# - It has not been approved (or approval was superseded by changes requested/dismissed)
# - The last activity (comment, review, or commit) was from the PR author or prompter (for bot PRs)
#
# The workflow runs on demand and updates issue #13834 with a table of PRs needing review,
# sorted by last updated date (most recent first).

name: Update PRs Needing Review

on:
  workflow_dispatch:

permissions:
  issues: write
  pull-requests: read

jobs:
  get-prs-needing-review:
    runs-on: ubuntu-latest
    if: ${{ github.repository_owner == 'dotnet' }}
    outputs:
      prs: ${{ steps.get-prs.outputs.prs }}
    steps:
      - name: Get PRs needing review
        id: get-prs
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea  # v7.0.1
        with:
          script: |
            // Get all open PRs
            const { data: pullRequests } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              sort: 'updated',
              direction: 'desc',
              per_page: 1000
            });
            
            const prsNeedingReview = [];
            
            for (const pr of pullRequests) {
              // Skip draft PRs
              if (pr.draft) {
                continue;
              }
              
              // Get reviews to check if PR is approved
              const { data: reviews } = await github.rest.pulls.listReviews({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number
              });
              
              // Check if there's a current approval by looking at each reviewer's most recent review
              // A reviewer might approve, then later request changes - we need the latest state
              const reviewerStates = new Map();
              for (const review of reviews) {
                // Only consider meaningful review states (not COMMENTED or PENDING)
                if (['APPROVED', 'CHANGES_REQUESTED', 'DISMISSED'].includes(review.state)) {
                  const reviewer = review.user.login.toLowerCase();
                  const existingReview = reviewerStates.get(reviewer);
                  const reviewDate = new Date(review.submitted_at);
                  
                  if (!existingReview || reviewDate > existingReview.date) {
                    reviewerStates.set(reviewer, { state: review.state, date: reviewDate });
                  }
                }
              }
              
              // PR is approved if at least one reviewer's latest state is APPROVED
              const isApproved = Array.from(reviewerStates.values()).some(r => r.state === 'APPROVED');
              if (isApproved) {
                continue;
              }
              
              // Get the PR author
              const prAuthor = pr.user.login;
              
              // For Copilot-created PRs, check if there's a prompter
              // Bot accounts have '[bot]' suffix in their username
              const isBotPr = prAuthor.endsWith('[bot]');
              
              // Get the prompter from the PR body if it's a bot PR
              let prompter = null;
              if (isBotPr && pr.body) {
                // Look for patterns like "Triggered by @username" or "Requested by @username"
                const prompterMatch = pr.body.match(/(?:triggered|requested|prompted)\s+by\s+@(\w+)/i);
                if (prompterMatch) {
                  prompter = prompterMatch[1];
                }
              }
              
              // Users who can't approve this PR (author and prompter)
              const cannotApprove = new Set([prAuthor.toLowerCase()]);
              if (prompter) {
                cannotApprove.add(prompter.toLowerCase());
              }
              
              // Get the last activity - check both comments and commits
              let lastExternalActivity = null;
              let lastExternalUser = null;
              
              // Get issue comments (regular comments)
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                per_page: 1000
              });
              
              // Get review comments (inline code comments)
              const { data: reviewComments } = await github.rest.pulls.listReviewComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number,
                per_page: 1000
              });
              
              // Get commits to check the last pusher
              const { data: commits } = await github.rest.pulls.listCommits({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number,
                per_page: 1000
              });
              
              // Check comments for last external activity
              for (const comment of comments) {
                const commentUser = comment.user.login.toLowerCase();
                if (!cannotApprove.has(commentUser)) {
                  const commentDate = new Date(comment.created_at);
                  if (!lastExternalActivity || commentDate > lastExternalActivity) {
                    lastExternalActivity = commentDate;
                    lastExternalUser = comment.user.login;
                  }
                }
              }
              
              // Check review comments
              for (const comment of reviewComments) {
                const commentUser = comment.user.login.toLowerCase();
                if (!cannotApprove.has(commentUser)) {
                  const commentDate = new Date(comment.created_at);
                  if (!lastExternalActivity || commentDate > lastExternalActivity) {
                    lastExternalActivity = commentDate;
                    lastExternalUser = comment.user.login;
                  }
                }
              }
              
              // Check reviews (for review submissions)
              for (const review of reviews) {
                const reviewUser = review.user.login.toLowerCase();
                if (!cannotApprove.has(reviewUser) && review.submitted_at) {
                  const reviewDate = new Date(review.submitted_at);
                  if (!lastExternalActivity || reviewDate > lastExternalActivity) {
                    lastExternalActivity = reviewDate;
                    lastExternalUser = review.user.login;
                  }
                }
              }
              
              // Track the last activity from someone who CAN'T approve (author/prompter)
              let lastInternalActivity = null;
              
              // Check commits for activity from author/prompter
              if (commits.length > 0) {
                const lastCommit = commits[commits.length - 1];
                const commitAuthor = lastCommit.author?.login?.toLowerCase();
                const commitCommitter = lastCommit.committer?.login?.toLowerCase();
                const commitDate = new Date(lastCommit.commit.committer.date);
                
                const isAuthorInternal = commitAuthor && cannotApprove.has(commitAuthor);
                const isCommitterInternal = commitCommitter && cannotApprove.has(commitCommitter);
                
                if (isAuthorInternal || isCommitterInternal) {
                  lastInternalActivity = commitDate;
                }
              }
              
              // Check comments from author/prompter
              for (const comment of comments) {
                const commentUser = comment.user.login.toLowerCase();
                if (cannotApprove.has(commentUser)) {
                  const commentDate = new Date(comment.created_at);
                  if (!lastInternalActivity || commentDate > lastInternalActivity) {
                    lastInternalActivity = commentDate;
                  }
                }
              }
              
              // Check review comments from author/prompter
              for (const comment of reviewComments) {
                const commentUser = comment.user.login.toLowerCase();
                if (cannotApprove.has(commentUser)) {
                  const commentDate = new Date(comment.created_at);
                  if (!lastInternalActivity || commentDate > lastInternalActivity) {
                    lastInternalActivity = commentDate;
                  }
                }
              }
              
              // Determine if the PR needs review:
              // The last activity should be from someone who can't approve (author/prompter)
              // meaning the ball is in the reviewers' court
              let needsReview = false;
              
              if (lastInternalActivity && lastExternalActivity) {
                // Both have activity - needs review if author/prompter acted last
                needsReview = lastInternalActivity > lastExternalActivity;
              } else if (lastInternalActivity && !lastExternalActivity) {
                // Only author/prompter has activity - needs review
                needsReview = true;
              }
              // If only external activity or no activity at all, doesn't need review
              
              if (needsReview) {
                prsNeedingReview.push({
                  number: pr.number,
                  title: pr.title,
                  author: pr.user.login,
                  url: pr.html_url,
                  authorUrl: pr.user.html_url,
                  updatedAt: pr.updated_at
                });
              }
            }
            
            // Sort by updated date descending
            prsNeedingReview.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
            
            console.log('Found ' + prsNeedingReview.length + ' PRs needing review');
            core.setOutput('prs', JSON.stringify(prsNeedingReview));

  update-tracking-issue:
    runs-on: ubuntu-latest
    needs: get-prs-needing-review
    steps:
      - name: Update tracking issue
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea  # v7.0.1
        with:
          script: |
            // Issue number to update with the PR list
            const TRACKING_ISSUE_NUMBER = 13834;
            
            // Unique marker to identify the automated content
            const marker = '<!-- pr-review-needed-list -->';
            
            // Get PRs from previous job
            const prsNeedingReview = JSON.parse('${{ needs.get-prs-needing-review.outputs.prs }}');
            
            // Format time since last update
            function formatTimeSince(dateStr) {
              const date = new Date(dateStr);
              const now = new Date();
              const diffMs = now - date;
              const diffMins = Math.floor(diffMs / (1000 * 60));
              const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
              const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
              
              if (diffDays > 0) {
                return diffDays + ' day' + (diffDays === 1 ? '' : 's') + ' ago';
              } else if (diffHours > 0) {
                return diffHours + ' hour' + (diffHours === 1 ? '' : 's') + ' ago';
              } else {
                return diffMins + ' minute' + (diffMins === 1 ? '' : 's') + ' ago';
              }
            }
            
            // Build the table
            let tableContent = marker + '\n';
            tableContent += '## PRs Needing Review\n\n';
            tableContent += '_Last updated: ' + new Date().toISOString() + '_\n\n';
            
            if (prsNeedingReview.length === 0) {
              tableContent += 'ðŸŽ‰ No PRs currently need review!\n';
            } else {
              tableContent += '| PR | Author | Last Updated |\n';
              tableContent += '|---|---|---|\n';
              for (const pr of prsNeedingReview) {
                // Use display name without @ to avoid notifications
                const authorLink = '[' + pr.author + '](' + pr.authorUrl + ')';
                const prLink = '[#' + pr.number + ' - ' + pr.title + '](' + pr.url + ')';
                const timeSince = formatTimeSince(pr.updatedAt);
                tableContent += '| ' + prLink + ' | ' + authorLink + ' | ' + timeSince + ' |\n';
              }
            }
            
            tableContent += '\n_This list is automatically updated every hour._';
            
            // Get the current issue
            const { data: issue } = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: TRACKING_ISSUE_NUMBER
            });
            
            // Check if the issue body contains our marker
            let newBody;
            if (issue.body && issue.body.includes(marker)) {
              // Replace the existing content from marker to end
              const markerIndex = issue.body.indexOf(marker);
              newBody = issue.body.substring(0, markerIndex) + tableContent;
            } else {
              // Append to the existing body
              newBody = (issue.body || '') + '\n\n' + tableContent;
            }
            
            // Update the issue
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: TRACKING_ISSUE_NUMBER,
              body: newBody
            });
            
            console.log('Updated issue #' + TRACKING_ISSUE_NUMBER + ' with ' + prsNeedingReview.length + ' PRs needing review');
