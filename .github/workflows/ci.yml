name: CI

on:
  pull_request:
    branches:
      - main
      - 'release/**'

  push:
    branches:
      - main
      - 'release/**'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ github.ref != 'refs/heads/main' }}

jobs:

  prepare_for_ci:
    runs-on: ubuntu-latest
    name: Prepare for CI
    if: ${{ github.repository_owner == 'dotnet' }}
    outputs:
      skip_workflow: ${{ (steps.check_docs.outputs.no_changes == 'true' || steps.check_docs.outputs.only_changed == 'true') && 'true' || 'false' }}
      VERSION_SUFFIX_OVERRIDE: ${{ steps.compute_version_suffix.outputs.VERSION_SUFFIX_OVERRIDE }}

    steps:
      - name: Checkout code
        if: ${{ github.event_name == 'pull_request' }}
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2
        with:
          fetch-depth: 0

      - name: Check for any changes that require CI
        id: check_docs
        if: ${{ github.event_name == 'pull_request' }}
        uses: ./.github/actions/check-changed-files
        with:
          patterns: |
            \.md$
            eng/pipelines/.*

      - id: compute_version_suffix
        name: Compute version suffix for PRs
        if: ${{ github.event_name == 'pull_request' }}
        shell: pwsh
        env:
          # Use the pull request head SHA instead of GITHUB_SHA (which can be a merge commit)
          PR_HEAD_SHA: ${{ github.event.pull_request.head.sha }}
          PR_NUMBER: ${{ github.event.number }}
        run: |
          Write-Host "Determining VERSION_SUFFIX_OVERRIDE (PR only step)..."
          if ([string]::IsNullOrWhiteSpace($Env:PR_HEAD_SHA)) {
            Write-Error "PR_HEAD_SHA not set; cannot compute version suffix."
            exit 1
          }
          $SHORT_SHA = $Env:PR_HEAD_SHA.Substring(0,8)
          $VERSION_SUFFIX = "/p:VersionSuffix=pr.$($Env:PR_NUMBER).g$SHORT_SHA"
          Write-Host "Computed VERSION_SUFFIX_OVERRIDE=$VERSION_SUFFIX"
          "VERSION_SUFFIX_OVERRIDE=$VERSION_SUFFIX" | Out-File -FilePath $Env:GITHUB_OUTPUT -Append -Encoding utf8

  tests:
    uses: ./.github/workflows/tests.yml
    name: Tests
    needs: [prepare_for_ci]
    if: ${{ github.repository_owner == 'dotnet' && needs.prepare_for_ci.outputs.skip_workflow != 'true' }}
    with:
      versionOverrideArg: ${{ needs.prepare_for_ci.outputs.VERSION_SUFFIX_OVERRIDE }}

  build_cli_archives:
    uses: ./.github/workflows/build-cli-native-archives.yml
    name: Build native CLI archives
    needs: [prepare_for_ci]
    if: ${{ github.repository_owner == 'dotnet' && needs.prepare_for_ci.outputs.skip_workflow != 'true' }}
    with:
      versionOverrideArg: ${{ needs.prepare_for_ci.outputs.VERSION_SUFFIX_OVERRIDE }}

  # This job is used for branch protection. It fails if any of the dependent jobs failed
  results:
    if: ${{ always() && github.repository_owner == 'dotnet' }}
    runs-on: ubuntu-latest
    name: Final Results
    needs: [prepare_for_ci, tests, build_cli_archives]

    steps:
      - name: Fail if any of the dependent jobs failed
        # Don't fail if the workflow is being skipped.
        # Check skip_workflow on all declared dependencies.
        #
        # For others 'skipped' can be when a transitive dependency fails and the dependent job gets
        # 'skipped'. For example, one of setup_* jobs failing and the Integration test jobs getting
        # 'skipped'
        if: >-
          ${{ always() &&
              needs.prepare_for_ci.outputs.skip_workflow != 'true' &&
              needs.tests.outputs.skip_workflow != 'true' &&
              needs.build_cli_archives.outputs.skip_workflow != 'true' &&
              (contains(needs.*.result, 'failure') ||
               contains(needs.*.result, 'cancelled') ||
               contains(needs.*.result, 'skipped')) }}
        run: |
          echo "One or more dependent jobs failed."
          exit 1
