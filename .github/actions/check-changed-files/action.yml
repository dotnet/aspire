name: 'Check Changed Files'
description: |
  Check if all changed files in a PR match provided glob patterns.

  This action compares changed files in a pull request against one or more glob patterns
  and determines if all changed files match at least one of the provided patterns.
  It only supports pull_request events.

  Inputs:
  - patterns_file: Path to a file containing glob patterns (relative to repository root).
                   Lines starting with '#' and blank lines are ignored.

  Pattern syntax:
  - **  matches any path including directory separators (recursive)
  - *   matches any characters except a directory separator
  - .   is treated as a literal dot (no escaping needed)

  Outputs:
  - only_changed: Boolean indicating if all changed files matched the patterns
  - no_changes: Boolean indicating if there were no changed files in the PR
  - changed_files: JSON array of all changed files in the PR
  - matched_files: JSON array of files that matched at least one pattern
  - unmatched_files: JSON array of files that didn't match any pattern
inputs:
  patterns_file:
    description: 'Path to a file containing glob patterns (relative to repository root)'
    required: true

outputs:
  only_changed:
    description: 'True if all changed files match the provided patterns, false otherwise'
    value: ${{ steps.check_files.outputs.only_changed }}
  no_changes:
    description: 'True if there were no changed files in the PR, false otherwise'
    value: ${{ steps.check_files.outputs.no_changes }}
  changed_files:
    description: 'List of changed files'
    value: ${{ steps.check_files.outputs.changed_files }}
  matched_files:
    description: 'List of changed files that matched the patterns'
    value: ${{ steps.check_files.outputs.matched_files }}
  unmatched_files:
    description: 'List of changed files that did not match any pattern'
    value: ${{ steps.check_files.outputs.unmatched_files }}

runs:
  using: "composite"
  steps:
    - name: Check changed files against patterns
      id: check_files
      shell: bash
      run: |
        set -ex

        # Only support pull request events
        if [ "${{ github.event_name }}" != "pull_request" ]; then
          echo "Error: This action only supports pull_request events, got: ${{ github.event_name }}"
          exit 1
        fi

        # Check if jq is available
        if ! command -v jq >/dev/null 2>&1; then
          echo "Error: jq is required but not installed"
          exit 1
        fi

        # Convert a glob pattern to an anchored ERE regex pattern.
        # Glob syntax supported:
        #   **   matches any path including directory separators
        #   *    matches any characters except a directory separator
        #   .    is treated as a literal dot
        #   All other characters are treated as literals.
        glob_to_regex() {
          local glob="$1"
          local result="$glob"
          # Replace ** and * with placeholders before escaping
          result="${result//\*\*/__DOUBLESTAR__}"
          result="${result//\*/__STAR__}"
          # Escape regex metacharacters that could appear in file paths.
          # Note: { } ^ $ are not escaped because they are either not special
          # in ERE mid-pattern or cannot appear in file paths.
          result="${result//\\/\\\\}"
          result="${result//./\\.}"
          result="${result//+/\\+}"
          result="${result//\?/\\?}"
          result="${result//\[/\\[}"
          result="${result//\]/\\]}"
          result="${result//\(/\\(}"
          result="${result//\)/\\)}"
          result="${result//|/\\|}"
          # Restore glob placeholders as regex
          result="${result//__STAR__/[^/]*}"
          result="${result//__DOUBLESTAR__/.*}"
          # Anchor to full path
          echo "^${result}$"
        }

        PATTERNS=()

        PATTERNS_FILE="${{ inputs.patterns_file }}"

        # Read glob patterns from file, skip comments and blank lines
        FULL_PATH="${GITHUB_WORKSPACE}/${PATTERNS_FILE}"
        if [ ! -f "$FULL_PATH" ]; then
          echo "Error: patterns_file '$FULL_PATH' not found"
          exit 1
        fi
        while IFS= read -r line; do
          # Remove leading/trailing whitespace
          line=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          # Skip blank lines and comments
          if [ -z "$line" ] || [[ "$line" == \#* ]]; then
            continue
          fi
          PATTERNS+=("$(glob_to_regex "$line")")
        done < "$FULL_PATH"

        # Check if we have any valid patterns
        if [ ${#PATTERNS[@]} -eq 0 ]; then
          echo "Error: No valid patterns provided"
          exit 1
        fi

        # Get list of changed files for pull requests
        BASE_REF="${{ github.event.pull_request.base.sha }}"
        HEAD_REF="${{ github.event.pull_request.head.sha }}"
        if ! CHANGED_FILES=$(git diff --name-only "$BASE_REF".."$HEAD_REF" 2>/dev/null); then
          echo "Error: Failed to get changed files. Base ref: $BASE_REF HEAD ref: $HEAD_REF"
          exit 1
        fi

        echo "Changed files:"
        echo "$CHANGED_FILES"

        # Initialize arrays
        MATCHED_FILES=()
        UNMATCHED_FILES=()

        # Handle the case where there are no changed files
        if [ -z "$CHANGED_FILES" ]; then
          echo "No files changed in this PR"
          ONLY_CHANGED="true"  # No files changed - treat as success
          NO_CHANGES="true"
        else
          # Check each changed file against patterns
          while IFS= read -r file; do
            if [ -z "$file" ]; then
              continue
            fi

            MATCHED=false
            for pattern in "${PATTERNS[@]}"; do
              # Use safe regex matching with error handling
              if [[ "$file" =~ $pattern ]] 2>/dev/null; then
                MATCHED=true
                break
              fi
            done

            if [ "$MATCHED" = true ]; then
              MATCHED_FILES+=("$file")
            else
              UNMATCHED_FILES+=("$file")
            fi
          done <<< "$CHANGED_FILES"

          # Determine if only matched files changed
          if [ ${#UNMATCHED_FILES[@]} -eq 0 ]; then
            ONLY_CHANGED="true"  # All changed files matched
          else
            ONLY_CHANGED="false"  # Some files didn't match
          fi
          NO_CHANGES="false"
        fi

        # Convert arrays to JSON for output (handle empty arrays safely)
        if [ -z "$CHANGED_FILES" ]; then
          CHANGED_FILES_JSON="[]"
        else
          CHANGED_FILES_JSON=$(printf '%s\n' "$CHANGED_FILES" | jq -R . | jq -s .)
        fi

        if [ ${#MATCHED_FILES[@]} -eq 0 ]; then
          MATCHED_FILES_JSON="[]"
        else
          MATCHED_FILES_JSON=$(printf '%s\n' "${MATCHED_FILES[@]}" | jq -R . | jq -s .)
        fi

        if [ ${#UNMATCHED_FILES[@]} -eq 0 ]; then
          UNMATCHED_FILES_JSON="[]"
        else
          UNMATCHED_FILES_JSON=$(printf '%s\n' "${UNMATCHED_FILES[@]}" | jq -R . | jq -s .)
        fi

        # Set outputs with proper escaping
        {
          echo "only_changed=$ONLY_CHANGED"
          echo "no_changes=$NO_CHANGES"
          echo "changed_files<<EOF"
          echo "$CHANGED_FILES_JSON"
          echo "EOF"
          echo "matched_files<<EOF"
          echo "$MATCHED_FILES_JSON"
          echo "EOF"
          echo "unmatched_files<<EOF"
          echo "$UNMATCHED_FILES_JSON"
          echo "EOF"
        } >> $GITHUB_OUTPUT

        echo "Only changed matching files: $ONLY_CHANGED"
        echo "Matched files: ${MATCHED_FILES[*]}"
        echo "Unmatched files: ${UNMATCHED_FILES[*]}"
